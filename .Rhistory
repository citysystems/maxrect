indexFront[[i]][j] <- TRUE
numFront[i] <- numFront[i] + 1
}
}
}
sum(checkFront)
length(numFront[numFront == 0])
length(numFront[numFront == 1])
length(numFront[numFront == 2])
length(numFront[numFront > 2])
chunks <- vector("double", len_json)              # chunks of points marked as front
false_chunks <- vector("double", len_json)        # chunks of points not marked as front (used to ID problems)
offsetFront <- vector("double", len_json)         # what number of points to move to the back
deleteFront <- vector("double", len_json)         # what index point to remove
chunks2 <- vector("double", len_json)              # chunks of points marked as front
false_chunks2 <- vector("double", len_json)        # chunks of points not marked as front (used to ID problems)
for (i in 1:len_json){
preVal <- FALSE
arr <- indexFront[[i]]
for (j in 1:length(arr)){
if (j == 1 && arr[j]){chunks[i] <- chunks[i] + 1}
else if (j == 1 && arr[j] == FALSE){false_chunks[i] <- false_chunks[i] + 1}
else if (preVal == FALSE && arr[j]){chunks[i] <- chunks[i] + 1}
else if (preVal && arr[j] == FALSE){false_chunks[i] <- false_chunks[i] + 1}
preVal <- arr[j]
}
# Track which parcel's front vertices need reordering
# If false_chunks < chunks, reorder by length of first true chunk
if (false_chunks[i] < chunks[i]){
for (j in 1:length(arr)){
if (!arr[j]){
break
}
offsetFront[i] <- offsetFront[i] + 1
}
indexFront[[i]] <- c(indexFront[[i]][-1:-offsetFront[i]], indexFront[[i]][1:offsetFront[i]])
}
preVal <- FALSE
for (j in 1:length(arr)){
if (j == 1 && indexFront[[i]][j]){chunks2[i] <- chunks2[i] + 1}
else if (j == 1 && indexFront[[i]][j] == FALSE){false_chunks2[i] <- false_chunks2[i] + 1}
else if (preVal == FALSE && indexFront[[i]][j]){chunks2[i] <- chunks2[i] + 1}
else if (preVal && indexFront[[i]][j] == FALSE){false_chunks2[i] <- false_chunks2[i] + 1}
preVal <- indexFront[[i]][j]
}
if (chunks2[j] == 2){
for (j in 2:(length(arr)-1)){
if (isTRUE(indexFront[[i]][j] == TRUE && indexFront[[i]][j-1] == FALSE && indexFront[[i]][j+1] == FALSE)){
deleteFront[i] <- j
}
}
}
}
table(deleteFront)
json_data <-  parcel_data        #### DOUBLE CHECK THIS VARIABLE EVERY TIME
# Find number of landlocked parcels (all points are touching another parcel)
# First, pull all the coordinates for the first polygon for each parcel
checkFront <- vector("logical", len_json)   # Keep track of whether a parcel touches the front
numFront <- vector("double", len_json)      # Keep track of number of points that touch the front
indexFront <- vector("list", len_json)      # Keep track of index of points that touch the front
for (i in 1:len_json){
print(i)
if (typeof(json_data[[i]]) == "list"){
poly <- unique(drop(json_data[[i]][[1]]))
}
else if (typeof(json_data[[i]]) == "double"){
# if (length(dim(json_data[[i]])) > 3){
# poly <- drop(json_data[[i]])[1,,]
poly <- unique(drop(json_data[[i]]))
# }
# else{poly <- unique(json_data[[i]][1,,])}
}
else{
break
}
indexFront[[i]] <- vector("logical", dim(poly)[1])
for (j in 1:dim(poly)[1]){
if (isFront1(poly[j,])){
checkFront[i] <- TRUE
indexFront[[i]][j] <- TRUE
numFront[i] <- numFront[i] + 1
}
}
}
sum(checkFront)
length(numFront[numFront == 0])
length(numFront[numFront == 1])
length(numFront[numFront == 2])
length(numFront[numFront > 2])
chunks <- vector("double", len_json)              # chunks of points marked as front
false_chunks <- vector("double", len_json)        # chunks of points not marked as front (used to ID problems)
offsetFront <- vector("double", len_json)         # what number of points to move to the back
deleteFront <- vector("double", len_json)         # what index point to remove
chunks2 <- vector("double", len_json)              # chunks of points marked as front
false_chunks2 <- vector("double", len_json)        # chunks of points not marked as front (used to ID problems)
for (i in 1:len_json){
preVal <- FALSE
arr <- indexFront[[i]]
for (j in 1:length(arr)){
if (j == 1 && arr[j]){chunks[i] <- chunks[i] + 1}
else if (j == 1 && arr[j] == FALSE){false_chunks[i] <- false_chunks[i] + 1}
else if (preVal == FALSE && arr[j]){chunks[i] <- chunks[i] + 1}
else if (preVal && arr[j] == FALSE){false_chunks[i] <- false_chunks[i] + 1}
preVal <- arr[j]
}
# Track which parcel's front vertices need reordering
# If false_chunks < chunks, reorder by length of first true chunk
if (false_chunks[i] < chunks[i]){
for (j in 1:length(arr)){
if (!arr[j]){
break
}
offsetFront[i] <- offsetFront[i] + 1
}
indexFront[[i]] <- c(indexFront[[i]][-1:-offsetFront[i]], indexFront[[i]][1:offsetFront[i]])
}
preVal <- FALSE
for (j in 1:length(arr)){
if (j == 1 && indexFront[[i]][j]){chunks2[i] <- chunks2[i] + 1}
else if (j == 1 && indexFront[[i]][j] == FALSE){false_chunks2[i] <- false_chunks2[i] + 1}
else if (preVal == FALSE && indexFront[[i]][j]){chunks2[i] <- chunks2[i] + 1}
else if (preVal && indexFront[[i]][j] == FALSE){false_chunks2[i] <- false_chunks2[i] + 1}
preVal <- indexFront[[i]][j]
}
if (chunks2[j] == 2){
for (j in 2:(length(arr)-1)){
if (isTRUE(indexFront[[i]][j] && (!indexFront[[i]][j-1] && !indexFront[[i]][j+1]))){
deleteFront[i] <- j
}
}
}
}
table(deleteFront)
json_data <-  parcel_data        #### DOUBLE CHECK THIS VARIABLE EVERY TIME
# Find number of landlocked parcels (all points are touching another parcel)
# First, pull all the coordinates for the first polygon for each parcel
checkFront <- vector("logical", len_json)   # Keep track of whether a parcel touches the front
numFront <- vector("double", len_json)      # Keep track of number of points that touch the front
indexFront <- vector("list", len_json)      # Keep track of index of points that touch the front
for (i in 1:len_json){
print(i)
if (typeof(json_data[[i]]) == "list"){
poly <- unique(drop(json_data[[i]][[1]]))
}
else if (typeof(json_data[[i]]) == "double"){
# if (length(dim(json_data[[i]])) > 3){
# poly <- drop(json_data[[i]])[1,,]
poly <- unique(drop(json_data[[i]]))
# }
# else{poly <- unique(json_data[[i]][1,,])}
}
else{
break
}
indexFront[[i]] <- vector("logical", dim(poly)[1])
for (j in 1:dim(poly)[1]){
if (isFront1(poly[j,])){
checkFront[i] <- TRUE
indexFront[[i]][j] <- TRUE
numFront[i] <- numFront[i] + 1
}
}
}
sum(checkFront)
length(numFront[numFront == 0])
length(numFront[numFront == 1])
length(numFront[numFront == 2])
length(numFront[numFront > 2])
chunks <- vector("double", len_json)              # chunks of points marked as front
false_chunks <- vector("double", len_json)        # chunks of points not marked as front (used to ID problems)
offsetFront <- vector("double", len_json)         # what number of points to move to the back
deleteFront <- vector("double", len_json)         # what index point to remove
chunks2 <- vector("double", len_json)              # chunks of points marked as front
false_chunks2 <- vector("double", len_json)        # chunks of points not marked as front (used to ID problems)
for (i in 1:len_json){
preVal <- FALSE
arr <- indexFront[[i]]
for (j in 1:length(arr)){
if (j == 1 && arr[j]){chunks[i] <- chunks[i] + 1}
else if (j == 1 && arr[j] == FALSE){false_chunks[i] <- false_chunks[i] + 1}
else if (preVal == FALSE && arr[j]){chunks[i] <- chunks[i] + 1}
else if (preVal && arr[j] == FALSE){false_chunks[i] <- false_chunks[i] + 1}
preVal <- arr[j]
}
# Track which parcel's front vertices need reordering
# If false_chunks < chunks, reorder by length of first true chunk
if (false_chunks[i] < chunks[i]){
for (j in 1:length(arr)){
if (!arr[j]){
break
}
offsetFront[i] <- offsetFront[i] + 1
}
indexFront[[i]] <- c(indexFront[[i]][-1:-offsetFront[i]], indexFront[[i]][1:offsetFront[i]])
}
preVal <- FALSE
for (j in 1:length(arr)){
if (j == 1 && indexFront[[i]][j]){chunks2[i] <- chunks2[i] + 1}
else if (j == 1 && indexFront[[i]][j] == FALSE){false_chunks2[i] <- false_chunks2[i] + 1}
else if (preVal == FALSE && indexFront[[i]][j]){chunks2[i] <- chunks2[i] + 1}
else if (preVal && indexFront[[i]][j] == FALSE){false_chunks2[i] <- false_chunks2[i] + 1}
preVal <- indexFront[[i]][j]
}
if (chunks2[j] == 2){
for (j in 2:(length(arr)-1)){
if (isTRUE(indexFront[[i]][j] && (!indexFront[[i]][j-1] && !indexFront[[i]][j+1]))){
deleteFront[i] <<- j
print(i)
}
}
}
}
json_data <-  parcel_data        #### DOUBLE CHECK THIS VARIABLE EVERY TIME
# Find number of landlocked parcels (all points are touching another parcel)
# First, pull all the coordinates for the first polygon for each parcel
checkFront <- vector("logical", len_json)   # Keep track of whether a parcel touches the front
numFront <- vector("double", len_json)      # Keep track of number of points that touch the front
indexFront <- vector("list", len_json)      # Keep track of index of points that touch the front
for (i in 1:len_json){
print(i)
if (typeof(json_data[[i]]) == "list"){
poly <- unique(drop(json_data[[i]][[1]]))
}
else if (typeof(json_data[[i]]) == "double"){
# if (length(dim(json_data[[i]])) > 3){
# poly <- drop(json_data[[i]])[1,,]
poly <- unique(drop(json_data[[i]]))
# }
# else{poly <- unique(json_data[[i]][1,,])}
}
else{
break
}
indexFront[[i]] <- vector("logical", dim(poly)[1])
for (j in 1:dim(poly)[1]){
if (isFront1(poly[j,])){
checkFront[i] <- TRUE
indexFront[[i]][j] <- TRUE
numFront[i] <- numFront[i] + 1
}
}
}
sum(checkFront)
length(numFront[numFront == 0])
length(numFront[numFront == 1])
length(numFront[numFront == 2])
length(numFront[numFront > 2])
chunks <- vector("double", len_json)              # chunks of points marked as front
false_chunks <- vector("double", len_json)        # chunks of points not marked as front (used to ID problems)
offsetFront <- vector("double", len_json)         # what number of points to move to the back
deleteFront <- vector("double", len_json)         # what index point to remove
chunks2 <- vector("double", len_json)              # chunks of points marked as front
false_chunks2 <- vector("double", len_json)        # chunks of points not marked as front (used to ID problems)
for (i in 1:len_json){
preVal <- FALSE
arr <- indexFront[[i]]
for (j in 1:length(arr)){
if (j == 1 && arr[j]){chunks[i] <- chunks[i] + 1}
else if (j == 1 && arr[j] == FALSE){false_chunks[i] <- false_chunks[i] + 1}
else if (preVal == FALSE && arr[j]){chunks[i] <- chunks[i] + 1}
else if (preVal && arr[j] == FALSE){false_chunks[i] <- false_chunks[i] + 1}
preVal <- arr[j]
}
# Track which parcel's front vertices need reordering
# If false_chunks < chunks, reorder by length of first true chunk
if (false_chunks[i] < chunks[i]){
for (j in 1:length(arr)){
if (!arr[j]){
break
}
offsetFront[i] <- offsetFront[i] + 1
}
indexFront[[i]] <- c(indexFront[[i]][-1:-offsetFront[i]], indexFront[[i]][1:offsetFront[i]])
}
preVal <- FALSE
for (j in 1:length(arr)){
if (j == 1 && indexFront[[i]][j]){chunks2[i] <- chunks2[i] + 1}
else if (j == 1 && indexFront[[i]][j] == FALSE){false_chunks2[i] <- false_chunks2[i] + 1}
else if (preVal == FALSE && indexFront[[i]][j]){chunks2[i] <- chunks2[i] + 1}
else if (preVal && indexFront[[i]][j] == FALSE){false_chunks2[i] <- false_chunks2[i] + 1}
preVal <- indexFront[[i]][j]
}
if (chunks2[i] == 2){
for (j in 2:(length(arr)-1)){
if (isTRUE(indexFront[[i]][j] && (!indexFront[[i]][j-1] && !indexFront[[i]][j+1]))){
deleteFront[i] <- j
print(i)
}
}
}
}
table(deleteFront)
offsetFront[905]
offsetFront[2145]
parcelFront <- vector(mode = "list", len_json)     # Keep track of the points that touch the front
for (i in 1:len_json){
if (checkFront[i]){   # Check whether we need to save any points
parcelFront[[i]] <- array(dim = c(numFront[i],2))
index <- 1
if (typeof(json_data[[i]]) == "list"){
poly <- unique(drop(json_data[[i]][[1]]))
}
else if (typeof(json_data[[i]]) == "double"){
# if (length(dim(json_data[[i]])) > 3){
# poly <- drop(json_data[[i]])[1,,]
poly <- unique(drop(json_data[[i]]))
# }
# else{poly <- unique(json_data[[i]][1,,])}
}
for (j in 1:(dim(poly)[1])){
if (isFront1(poly[j,])){
parcelFront[[i]][index,] <- poly[j,]
index <- index + 1
}
}
}
if (deleteFront[i] > 0){
parcelFront[[i]] <- parcelFront[[i]][-deleteFront[i]]
}
# Check if indices need rearranging
if (offsetFront[i] > 0){
parcelFront[[i]] <- rbind(parcelFront[[i]][-1:-offsetFront[i], ], parcelFront[[i]][1:offsetFront[i], ])
}
}
parcelFront <- vector(mode = "list", len_json)     # Keep track of the points that touch the front
for (i in 1:len_json){
if (checkFront[i]){   # Check whether we need to save any points
parcelFront[[i]] <- array(dim = c(numFront[i],2))
index <- 1
if (typeof(json_data[[i]]) == "list"){
poly <- unique(drop(json_data[[i]][[1]]))
}
else if (typeof(json_data[[i]]) == "double"){
# if (length(dim(json_data[[i]])) > 3){
# poly <- drop(json_data[[i]])[1,,]
poly <- unique(drop(json_data[[i]]))
# }
# else{poly <- unique(json_data[[i]][1,,])}
}
for (j in 1:(dim(poly)[1])){
if (isFront1(poly[j,])){
parcelFront[[i]][index,] <- poly[j,]
index <- index + 1
}
}
}
if (deleteFront[i] > 0){
parcelFront[[i]] <- parcelFront[[i]][-deleteFront[i],]
}
# Check if indices need rearranging
if (offsetFront[i] > 0){
parcelFront[[i]] <- rbind(parcelFront[[i]][-1:-offsetFront[i], ], parcelFront[[i]][1:offsetFront[i], ])
}
}
eqscplot(parcelFront[[905]], type='l')
eqscplot(json_data[[905]], type='l')
eqscplot(parcelFront[[2145]], type='l')
lines(json_data[[2145]])
cornerStats <- vector(mode = "list", len_json)
for (i in 1:len_json){
if(is.null(parcelFront[[i]])) {next}
else if (dim(parcelFront[[i]])[1] < 3) {next}
arr <- parcelFront[[i]]
# Find angles
angle <- vector(mode = "double", length = dim(arr)[1]-1)
for (j in 1:length(angle)){
angle[j] <- atan2(arr[j+1,2]-arr[j,2], arr[j+1,1]-arr[j,1])
}
totang1 <- atan2(arr[dim(arr)[1],2]-arr[1,2], arr[dim(arr)[1],1]-arr[1,1])
totang2 <- totang1 - pi
# Save angles
cornerStats[[i]]$angles <- angle
# Average angle
cornerStats[[i]]$avg <- mean(angle)/pi*180
# Difference in angle between first segment and hypotenuse (first to last point)
cornerStats[[i]]$totdiff1 <- atan2(sin(totang1-angle[1]),cos(totang1-angle[1]))/pi*180
# Difference in angle between last segment and hypotenuse (first to last point)
cornerStats[[i]]$totdiff2 <- atan2(sin(totang2-angle[length(angle)]+pi),cos(totang2-angle[length(angle)]+pi))/pi*180
# Difference in angle between first segment and last segment
cornerStats[[i]]$segdiff <- atan2(sin(angle[length(angle)]-angle[1]), cos(angle[length(angle)]-angle[1]))/pi*180
}
isCorner <- vector("logical", len_json)
for (i in 1:len_json){
if (is.null(cornerStats[[i]])) {next}
# if mostly straight, skip
if (abs(cornerStats[[i]]$totdiff1) < 20 || abs(cornerStats[[i]]$totdiff2) < 20) {next}
# if first and last segment have more than 60 degrees diff, mark as corner
if (abs(cornerStats[[i]]$segdiff) >= 60) {isCorner[i] <- TRUE}
}
sum(isCorner)
isCorner <- vector("logical", len_json)
for (i in 1:len_json){
if (is.null(cornerStats[[i]])) {next}
# if mostly straight, skip
if (abs(cornerStats[[i]]$totdiff1) < 20 || abs(cornerStats[[i]]$totdiff2) < 20) {next}
# if first and last segment have more than 60 degrees diff, mark as corner
if (abs(cornerStats[[i]]$segdiff) >= 80) {isCorner[i] <- TRUE}
}
sum(isCorner)
isCorner <- vector("logical", len_json)
for (i in 1:len_json){
if (is.null(cornerStats[[i]])) {next}
# if mostly straight, skip
if (abs(cornerStats[[i]]$totdiff1) < 20 || abs(cornerStats[[i]]$totdiff2) < 20) {next}
# if first and last segment have more than 60 degrees diff, mark as corner
if (abs(cornerStats[[i]]$segdiff) >= 60) {isCorner[i] <- TRUE}
}
View(cornerStats[[1]])
for (i in 1:len_json){
if(is.null(parcelFront[[i]])) {next}
else if (dim(parcelFront[[i]])[1] < 3) {next}
arr <- parcelFront[[i]]
# Find angles
angle <- vector(mode = "double", length = dim(arr)[1]-1)
for (j in 1:length(angle)){
angle[j] <- atan2(arr[j+1,2]-arr[j,2], arr[j+1,1]-arr[j,1])
}
totang1 <- atan2(arr[dim(arr)[1],2]-arr[1,2], arr[dim(arr)[1],1]-arr[1,1])
totang2 <- totang1 - pi
# Save angles
cornerStats[[i]]$angles <- angle/pi*180
# Average angle
cornerStats[[i]]$avg <- mean(angle)/pi*180
# Difference in angle between first segment and hypotenuse (first to last point)
cornerStats[[i]]$totdiff1 <- atan2(sin(totang1-angle[1]),cos(totang1-angle[1]))/pi*180
# Difference in angle between last segment and hypotenuse (first to last point)
cornerStats[[i]]$totdiff2 <- atan2(sin(totang2-angle[length(angle)]+pi),cos(totang2-angle[length(angle)]+pi))/pi*180
# Difference in angle between first segment and last segment
cornerStats[[i]]$segdiff <- atan2(sin(angle[length(angle)]-angle[1]), cos(angle[length(angle)]-angle[1]))/pi*180
}
isCorner <- vector("logical", len_json)
View(cornerStats[[1]])
View(cornerStats[[1]])
test <- vector("list", len_json)
# Extract front edge for corner lot
# At some point, figure out how to read in roadway network. For now, arbitrarily choose one side and figure out cutoff point
for (i in 1:len_json){
if (isCorner[i]){  # Only modify if it is marked as a corner parcel
avg <- cornerStats[[i]]$avg
angles <- cornerStats[[i]]$angles
index <- 1       # Identify index for cutoff
if (angles[1] > avg){
while(angles[index] > avg){
index <- index + 1
}
} else if (angles[1] <= avg){
while(angles[index] < avg){
index <- index + 1
}
}
test[[i]] <- parcelFront[[i]][1:index,]
}
}
View(test)
sum(isCorner)
isCorner <- vector("logical", len_json)
for (i in 1:len_json){
if (is.null(cornerStats[[i]])) {next}
# if mostly straight, skip
if (abs(cornerStats[[i]]$totdiff1) < 20 || abs(cornerStats[[i]]$totdiff2) < 20) {next}
# if first and last segment have more than 60 degrees diff, mark as corner
if (abs(cornerStats[[i]]$segdiff) >= 60) {isCorner[i] <- TRUE}
}
sum(isCorner)
test <- vector("list", len_json)
# Extract front edge for corner lot
# At some point, figure out how to read in roadway network. For now, arbitrarily choose one side and figure out cutoff point
for (i in 1:len_json){
if (isCorner[i]){  # Only modify if it is marked as a corner parcel
avg <- cornerStats[[i]]$avg
angles <- cornerStats[[i]]$angles
index <- 1       # Identify index for cutoff
if (angles[1] > avg){
while(angles[index] > avg){
index <- index + 1
}
} else if (angles[1] <= avg){
while(angles[index] < avg){
index <- index + 1
}
}
test[[i]] <- parcelFront[[i]][1:index,]
}
}
View(test)
eqscplot(test[[6]],type='l')
?eqscplot()
eqscplot(test[[6]],type='l', tol = 0.5)
lines(parcelFront[[6]])
eqscplot(parcelFront[[6]],type='l')
eqscplot(test[[22]],type='l', tol = 0.5)
lines(parcelFront[[22]])
eqscplot(parcelFront[[22]],type='l')
# Extract front edge for corner lot
# At some point, figure out how to read in roadway network. For now, arbitrarily choose one side and figure out cutoff point
for (i in 1:len_json){
if (isCorner[i]){  # Only modify if it is marked as a corner parcel
avg <- cornerStats[[i]]$avg
angles <- cornerStats[[i]]$angles
index <- 1       # Identify index for cutoff
if (angles[1] > avg){
while(angles[index] > avg){
index <- index + 1
}
} else if (angles[1] <= avg){
while(angles[index] < avg){
index <- index + 1
}
}
parcelFront[[i]] <- parcelFront[[i]][1:index,]
}
}
