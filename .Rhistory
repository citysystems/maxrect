return (TRUE)
}
n <- nrow(poly)
b <- poly[n,]
c <- 0
for (i in 1:n){
a <- b
b <- poly[i,]
if (rayIntersectsSegment(p, a, b)){
c <- c + 1
}
}
return (c %% 2 != 0)
}
pointInPoly(poly1mod[2,], poly1mod, eps = 1)
test <- findBuildable(testpolygon)
plot(test)
pointInPoly(poly1mod[2,], poly1mod, eps = 1)
polyInsidePoly(rect, poly1mod)
polyIntersect(rect, poly1mod)
polyInsidePoly(rect, poly1mod)
pointOnPolygon(rect[1,], poly1mod)
rect
pointOnPolygon(rect[2,], poly1mod)
pointOnPolygon(rect[3,], poly1mod)
pointOnPolygon(rect[4,], poly1mod)
eqscplot(poly1mod, type='l')
lines(rect)
pointInPoly(rect[4,], poly1mod)
rect[4.]
rect[4,]
pointInPoly(c(100,10), poly1mod)
# Checks whether the point p is inside a polygon using the Ray-Casting algorithm
# Implementation from: http://rosettacode.org/wiki/Ray-casting_algorithm#CoffeeScript
# If exclusive, points on the polygon are not counted as inside polygon
pointInPoly <- function(p, poly, exclusive = FALSE, eps = 1e-9){
if(pointOnPolygon(p, poly, eps)){
return (!exclusive)
}
n <- nrow(poly)
b <- poly[n,]
c <- 0
for (i in 1:n){
a <- b
b <- poly[i,]
if (rayIntersectsSegment(p, a, b)){
c <- c + 1
}
}
return (c %% 2 != 0)
}
pointInPoly(c(100,10), poly1mod)
pointInPoly(c(100,50), poly1mod)
poly1mod
pointInPoly(c(10,10), cbind(c(0,20,20,0),c(0,0,20,20)))
pointInPoly(c(100,8), cbind(c(100,200,180,80),c(0,0,100,100)))
pointInPoly(c(100,8), cbind(c(100,200,180,80,100),c(0,0,100,100,0)))
# Checks whether the point p is inside a polygon using the Ray-Casting algorithm
# Implementation from: http://rosettacode.org/wiki/Ray-casting_algorithm#CoffeeScript
# If exclusive, points on the polygon are not counted as inside polygon
pointInPoly <- function(p, poly, exclusive = FALSE, eps = 1e-9){
if(pointOnPolygon(p, poly, eps)){
return (!exclusive)
}
n <- nrow(poly)
b <- poly[n,]
c <- 0
for (i in 1:n){
a <- b
b <- poly[i,]
if (rayIntersectsSegment(p, a, b)){
c <- c + 1
}
}
print(c)
return (c %% 2 != 0)
}
pointInPoly(c(100,8), cbind(c(100,200,180,80,100),c(0,0,100,100,0)))
# Checks whether the point p is inside a polygon using the Ray-Casting algorithm
# Implementation from: http://rosettacode.org/wiki/Ray-casting_algorithm#CoffeeScript
# If exclusive, points on the polygon are not counted as inside polygon
pointInPoly <- function(p, poly, exclusive = FALSE, eps = 1e-9){
if(pointOnPolygon(p, poly, eps)){
return (!exclusive)
}
n <- nrow(poly)
b <- poly[n,]
c <- 0
for (i in 1:n){
a <- b
b <- poly[i,]
if (rayIntersectsSegment(p, a, b)){
c <- c + 1
print(i)
}
}
print(c)
return (c %% 2 != 0)
}
pointInPoly(c(100,8), cbind(c(100,200,180,80,100),c(0,0,100,100,0)))
pointInPoly(c(100,8), cbind(c(100,200,180,80),c(0,0,100,100)))
pointInPoly(c(200,8), cbind(c(100,200,180,80),c(0,0,100,100)))
pointInPoly(c(100,8), cbind(c(100,200,180,80),c(0,0,100,100)))
pointInPoly(c(100,10), cbind(c(100,200,180,80),c(0,0,100,100)))
pointInPoly(c(100,50), cbind(c(100,200,180,80),c(0,0,100,100)))
pointInPoly(c(100,8), cbind(c(200,180,80,100),c(0,100,100,0)))
eqscplot(cbind(c(200,180,80,100),c(0,100,100,0)))
rayIntersectsSegment(c(100,8),c(218,0),c(183,100))
rect
poly1mod
eqscplot(poly1mod, type='l')
rayIntersectsSegment(c(100,8),poly1mod[1,],poly1mod[2,])
100/45
atan2(8,0)
# Checks whether the point p is inside a polygon using the Ray-Casting algorithm
# Implementation from: http://rosettacode.org/wiki/Ray-casting_algorithm#CoffeeScript
# If exclusive, points on the polygon are not counted as inside polygon
pointInPoly <- function(p, poly, exclusive = FALSE, eps = 1e-9){
if(pointOnPolygon(p, poly, eps)){
return (!exclusive)
}
pf <- p + c(1e10,0)
n <- nrow(poly)
b <- poly[n,]
c <- 0
for (i in 1:n){
a <- b
b <- poly[i,]
if (segmentsIntersect(p, pf, a, b)){
c <- c + 1
print(i)
}
}
print(c)
return (c %% 2 != 0)
}
pointInPoly(c(100,8), cbind(c(200,180,80,100),c(0,100,100,0)))
# Checks whether the point p is inside a polygon using the Ray-Casting algorithm
# Implementation from: http://rosettacode.org/wiki/Ray-casting_algorithm#CoffeeScript
# If exclusive, points on the polygon are not counted as inside polygon
pointInPoly <- function(p, poly, exclusive = FALSE, eps = 1e-9){
if(pointOnPolygon(p, poly, eps)){
return (!exclusive)
}
pf <- p + c(1e10,0)
n <- nrow(poly)
b <- poly[n,]
c <- 0
for (i in 1:n){
a <- b
b <- poly[i,]
if (segmentsIntersect(p, pf, a, b)){
c <- c + 1
}
}
return (c %% 2 != 0)
}
pointInPoly(c(100,8), cbind(c(200,180,80,100),c(0,100,100,0)))
test <- findBuildable(testpolygon)
plot(test)
lines(testpolygon)
lines(rbind(testpolygon,testpolygon[1,])
)
test <- findBuildable(testpoly3)
length(list())
findBuildable <- function(poly1, poly2 = NULL){
# Make sure that polygons are not closed
if (identical(poly1[1,],poly1[nrow(poly1),])){
poly1 <- poly1[-1,]
}
validRects <- vector(mode = "list", length = 0)
if (is.null(poly2)){
for (i in 1:nrow(poly1)){
# Polygon is formatted as a 2 x N array of coordinates, no other information. If hole present, hole is in same format.
# N rows does not includes final row to close polygon
# Selected edge is poly1[i %% nrow(poly1) + 1,] and poly1[i,]
# Step 0: rotate polygon so selected edge is horizontal (0 degrees)
iplus1 <- i%%nrow(poly1) + 1
angle <- atan2((poly1[iplus1,2]-poly1[i,2]),(poly1[iplus1,1]-poly1[i,1]))
poly1mod <- rotatePoly(poly1, -angle, poly1[i,])
print(poly1mod)
eqscplot(poly1mod, type='l')
edge <- c(poly1mod[i,],poly1mod[iplus1,]) # edge = c(x1, y1, x2, y2)
# Step 1: find midpoint of edge
midpt <- (poly1mod[iplus1,] + poly1mod[i,]) / 2
# Step 2: Take 2 coordinates a small normal dist away. ID which one is inside poly
side1 <- midpt + c(0, 0.5)
side2 <- midpt - c(0, 0.5)    ## ***Note: this algorithm won't work if there is only a tiny sliver where the midpoint of segment is. Hopefully this doesn't pose an issue, or we will need to refine the process further...
offset <- c(0,0)
# Case A: side1 is inside polygon and outside of hole
if (pointInPoly(side1, poly1mod)){
offset <- c(0, 8)
# Just to check that there isn't an error, see if side1 is also valid. If yes, there is some issue that needs to be resolved.
if (pointInPoly(side2, poly1mod)){
print("Error: side 1 and 2 both valid")
}
}else if(pointInPoly(side2, poly1mod)){ # Case B: side2 is inside polygon and outside of hole
offset <- c(0, -8)
}else{
print("Error: both side 1 and 2 invalid. Skip")
next
}
# Step 3: construct parallel line segment ("parSeg") 8 ft away in appropriate direction (we will call the two || lines "the ribbon")
parSeg <- edge + c(offset, offset)
# Step 4: find all intersections between parSeg and other edges (polygon and hole)
intersections <- vector("numeric",0) # initialize vector to store intersecting X coordinates
# intersections <- rbind(intersections, edge[1:2], edge[3:4])
for (j in 1:nrow(poly1mod)){
jplus1 <- j %% nrow(poly1mod) + 1
seg <- c(poly1mod[j,], poly1mod[jplus1,])
# If line segment intersects, add to collection
if (segmentsIntersect(seg[1:2], seg[3:4], parSeg[1:2], parSeg[3:4], eps = 0)){
intersections <- c(intersections, lineIntersection(seg[1:2], seg[3:4], parSeg[1:2], parSeg[3:4])[1])
}
}
# Step 5: Find all poly vertices inside 8 ft wide ribbon.
for (j in 1:nrow(poly1mod)){
pt <- poly1mod[j,]
# edge = c(x1, y1, x2, y2)
if (pt[1] >= edge[1] && pt[1] <= edge[3] && pt[2] >= edge[2] && pt[2] <= edge[4]){
intersections <- c(intersections, pt[1])
}
}
# Get rid of redundant X coordinates
intersections <- round(intersections, digits = 5)
intersections <- unique(intersections)
print(edge, digits = 4)
print(parSeg, digits = 4)
print(intersections, digits = 4)
# Step 6: Construct all possible rectangles
# Initialize list vector for rectangle coordinates
rects <- vector(mode = "list", length = 0)
for (j in 1:(length(intersections)-1)){
print(paste("j =", j))
for (k in (j+1):length(intersections)){
print(paste("k =", k))
x1 <- intersections[j]
x2 <- intersections[k]
y1 <- midpt[2]
y2 <- (midpt + offset)[2]
if (x1 > x2){ # Make sure x1 is smaller than x2
temp <- x2
x2 <- x1
x1 <- temp
}
if (y1 > y2){ # Make sure y1 is smaller than y2
temp <- y2
y2 <- y1
y1 <- temp
}
# Quick check: if distance between x1 and x2 is less than 20, then skip
if (abs(x2-x1) < 20){
next
}
rect <- cbind(c(x1, x2, x2, x1), c(y1, y1, y2, y2))
rects[[length(rects)+1]] <- rect
}
}
print(rects, digits = 10)
# Check which rectangles are inside poly and keep them
if (length(rects) > 0){
for (j in 1:length(rects)){
rect <- rects[[j]]
if (!polyIntersect(rect, poly1mod) && polyInsidePoly(rect, poly1mod)){
# Rotate rectangle back to original orientation
rect <- rotatePoly(rect, angle, poly1[i,])
rect <- rbind(rect, rect[1,])
validRects[[length(validRects)+1]] <- rect
}
}
print(validRects, digits = 4)
}
}
} else{  # There is a hole
if (identical(poly2[1,],poly2[nrow(poly2),])){
poly2 <- poly2[-1,]
}
##### Run this for each edge in polygon
for (i in 1:nrow(poly1)){
# Polygon is formatted as a 2 x N array of coordinates, no other information. If hole present, hole is in same format.
# N rows does not includes final row to close polygon
# Selected edge is poly1[i %% nrow(poly1) + 1,] and poly1[i,]
# Step 0: rotate polygon so selected edge is horizontal (0 degrees)
iplus1 <- i%%nrow(poly1) + 1
angle <- atan2((poly1[iplus1,2]-poly1[i,2]),(poly1[iplus1,1]-poly1[i,1]))
poly1mod <- rotatePoly(poly1, -angle, poly1[i,])
poly2mod <- rotatePoly(poly2, -angle, poly1[i,])
edge <- c(poly1mod[i,],poly1mod[iplus1,]) # edge = c(x1, y1, x2, y2)
# Step 1: find midpoint of edge
midpt <- (poly1mod[iplus1,] + poly1mod[i,]) / 2
# Step 2: Take 2 coordinates a small normal dist away. ID which one is inside poly
side1 <- midpt + c(0, 0.5)
side2 <- midpt - c(0, 0.5)    ## ***Note: this algorithm won't work if there is only a tiny sliver where the midpoint of segment is. Hopefully this doesn't pose an issue, or we will need to refine the process further...
offset <- c(0,0)
# Case A: side1 is inside polygon and outside of hole
if (pointInPoly(side1, poly1mod) && !pointInPoly(side1, poly2mod)){
offset <- c(0, 8)
# Just to check that there isn't an error, see if side1 is also valid. If yes, there is some issue that needs to be resolved.
if (pointInPoly(side2, poly1mod) && !pointInPoly(side2, poly2mod)){
print("Error: side 1 and 2 both valid")
}
}else if(pointInPoly(side2, poly1mod) && !pointInPoly(side2, poly2mod)){ # Case B: side2 is inside polygon and outside of hole
offset <- c(0, -8)
}else {
print("Error: both side 1 and 2 invalid. Skip")
next
}
# Step 3: construct parallel line segment ("parSeg") 8 ft away in appropriate direction (we will call the two || lines "the ribbon")
parSeg <- edge + c(offset, offset)
# Step 4: find all intersections between parSeg and other edges (polygon and hole)
intersections <- vector("numeric",0) # initialize vector to store intersecting X coordinates
for (j in 1:nrow(poly1mod)){
jplus1 <- j %% nrow(poly1mod) + 1
seg <- c(poly1mod[j,], poly1mod[jplus1,])
# If line segment intersects, add to collection
if (segmentsIntersect(seg[1:2], seg[3:4], parSeg[1:2], parSeg[3:4], eps = 0)){
intersections <- c(intersections, lineIntersection(seg[1:2], seg[3:4], parSeg[1:2], parSeg[3:4])[1])
}
}
for (j in 1:nrow(poly2mod)){
jplus1 <- j %% nrow(poly2mod) + 1
seg <- c(poly2mod[j,], poly2mod[jplus1,])
# If line segment intersects, add to collection
if (segmentsIntersect(seg[1:2], seg[3:4], parSeg[1:2], parSeg[3:4], eps = 0)){
intersections <- c(intersections, lineIntersection(seg[1:2], seg[3:4], parSeg[1:2], parSeg[3:4])[1])
}
}
# Step 5: Find all poly vertices inside 8 ft wide ribbon.
for (j in 1:nrow(poly1mod)){
pt <- poly1mod[j,]
# edge = c(x1, y1, x2, y2)
if (pt[1] >= edge[1] && pt[1] <= edge[3] && pt[2] >= edge[2] && pt[2] <= edge[4]){
intersections <- c(intersections, pt[1])
}
}
for (j in 1:nrow(poly2mod)){
pt <- poly2mod[j,]
if (pt[1] >= edge[1] && pt[1] <= edge[3] && pt[2] >= edge[2] && pt[2] <= edge[4]){
intersections <- c(intersections, pt[1])
}
}
# Get rid of redundant X coordinates
intersections <- unique(intersections)
# Step 6: Construct all possible rectangles
# Initialize list vector for rectangle coordinates
rects <- vector(mode = "list", length = 0)
for (j in 1:(length(intersections)-1)){
for (k in (j+1):length(intersections)){
x1 <- intersections[j]
x2 <- intersections[k]
y1 <- midpt[2]
y2 <- (midpt + offset)[2]
if (x1 > x2){ # Make sure x1 is smaller than x2
temp <- x2
x2 <- x1
x1 <- temp
}
if (y1 > y2){ # Make sure y1 is smaller than y2
temp <- y2
y2 <- y1
y1 <- temp
}
# Quick check: if distance between x1 and x2 is less than 20, then skip
if (abs(x2-x1) < 20){
next
}
rect <- cbind(c(x1, x2, x2, x1), c(y1, y1, y2, y2))
rects[[length(rects)+1]] <- rect
}
}
# Check which rectangles are inside poly and keep them
for (j in 1:length(rects)){
rect <- rects[[j]]
if (!polyIntersect(rect, poly1mod) && !polyIntersect(rect, poly2mod) && polyInsidePoly(rect, poly1mod) && !polyInsidePoly(rect, poly2mod) && !polyInsidePoly(poly2mod, rect)){
# Rotate rectangle back to original orientation
rect <- rotatePoly(rect, angle, poly1[i,])
rect <- rbind(rect, rect[1,])
validRects[[length(validRects)+1]] <- rect
}
}
}
#### Run this again for each edge in hole (if present)
for (i in 1:nrow(poly2)){
# Polygon is formatted as a 2 x N array of coordinates, no other information. If hole present, hole is in same format.
# N rows does not includes final row to close polygon
# Selected edge is poly2[i %% nrow(poly2) + 1,] and poly2[i,]
# Step 0: rotate hole & polygon so selected hole edge is horizontal (0 degrees)
iplus1 <- i%%nrow(poly2) + 1
angle <- atan2((poly2[iplus1,2]-poly2[i,2]),(poly2[iplus1,1]-poly2[i,1]))
poly1mod <- rotatePoly(poly1, -angle, poly1[i,])
poly2mod <- rotatePoly(poly2, -angle, poly1[i,])
edge <- c(poly2mod[i,],poly2mod[iplus1,]) # edge = c(x1, y1, x2, y2)
# Step 1: find midpoint of edge
midpt <- (poly2mod[iplus1,] + poly2mod[i,]) / 2
# Step 2: Take 2 coordinates a small normal dist away. ID which one is inside poly
side1 <- midpt + c(0, 0.5)
side2 <- midpt - c(0, 0.5)    ## ***Note: this algorithm won't work if there is only a tiny sliver where the midpoint of segment is. Hopefully this doesn't pose an issue, or we will need to refine the process further...
offset <- c(0,0)
# Case A: side1 is inside polygon and outside of hole
if (pointInPoly(side1, poly1mod) && !pointInPoly(side1, poly2mod)){
offset <- c(0, 8)
# Just to check that there isn't an error, see if side1 is also valid. If yes, there is some issue that needs to be resolved.
if (pointInPoly(side2, poly1mod) && !pointInPoly(side2, poly2mod)){
print("Error: side 1 and 2 both valid")
}
}else if(pointInPoly(side2, poly1mod) && !pointInPoly(side2, poly2mod)){ # Case B: side2 is inside polygon and outside of hole
offset <- c(0, -8)
}else {
print("Error: both side 1 and 2 are invalid. Skip")
next
}
# Step 3: construct parallel line segment ("parSeg") 8 ft away in appropriate direction (we will call the two || lines "the ribbon")
parSeg <- edge + c(offset, offset)
# Step 4: find all intersections between parSeg and other edges (polygon and hole)
intersections <- vector("numeric",0) # initialize vector to store intersecting X coordinates
for (j in 1:nrow(poly1mod)){
jplus1 <- j %% nrow(poly1mod) + 1
seg <- c(poly1mod[j,], poly1mod[jplus1,])
# If line segment intersects, add to collection
if (segmentsIntersect(seg[1:2], seg[3:4], parSeg[1:2], parSeg[3:4], eps = 0)){
intersections <- c(intersections, lineIntersection(seg[1:2], seg[3:4], parSeg[1:2], parSeg[3:4])[1])
}
}
for (j in 1:nrow(poly2mod)){
jplus1 <- j %% nrow(poly2mod) + 1
seg <- c(poly2mod[j,], poly2mod[jplus1,])
# If line segment intersects, add to collection
if (segmentsIntersect(seg[1:2], seg[3:4], parSeg[1:2], parSeg[3:4], eps = 0)){
intersections <- c(intersections, lineIntersection(seg[1:2], seg[3:4], parSeg[1:2], parSeg[3:4])[1])
}
}
# Step 5: Find all poly vertices inside 8 ft wide ribbon.
for (j in 1:nrow(poly1mod)){
pt <- poly1mod[j,]
# edge = c(x1, y1, x2, y2)
if (pt[1] >= edge[1] && pt[1] <= edge[3] && pt[2] >= edge[2] && pt[2] <= edge[4]){
intersections <- c(intersections, pt[1])
}
}
for (j in 1:nrow(poly2mod)){
pt <- poly2mod[j,]
if (pt[1] >= edge[1] && pt[1] <= edge[3] && pt[2] >= edge[2] && pt[2] <= edge[4]){
intersections <- c(intersections, pt[1])
}
}
# Get rid of redundant X coordinates
intersections <- unique(intersections)
# Step 6: Construct all possible rectangles
# Initialize list vector for rectangle coordinates
rects <- vector(mode = "list", length = 0)
for (j in 1:(nrow(intersections)-1)){
for (k in (j+1):nrow(intersections)){
x1 <- intersections[j,1]
x2 <- intersections[k,1]
y1 <- midpt[2]
y2 <- (midpt + offset)[2]
if (x1 > x2){ # Make sure x1 is smaller than x2
temp <- x2
x2 <- x1
x1 <- temp
}
if (y1 > y2){ # Make sure y1 is smaller than y2
temp <- y2
y2 <- y1
y1 <- temp
}
# Quick check: if distance between x1 and x2 is less than 20, then skip
if (abs(x2-x1) < 20){
next
}
rect <- cbind(c(x1, x2, x2, x1), c(y1, y1, y2, y2))
rects[[length(rects)+1]] <- rect
}
}
# Check which rectangles are inside poly and keep them
for (j in 1:length(rects)){
rect <- rects[[j]]
if (!polyIntersect(rect, poly1mod) && !polyIntersect(rect, poly2mod) && polyInsidePoly(rect, poly1mod) && !polyInsidePoly(rect, poly2mod) && !polyInsidePoly(poly2mod, rect)){
# Rotate rectangle back to original orientation
rect <- rotatePoly(rect, angle, poly1[i,])
rect <- rbind(rect, rect[1,])
validRects[[length(validRects)+1]] <- rect
}
}
}
}
if (length(validRects) > 1){
rects <- vector("list", length(validRects))
for (j in 1:length(validRects)){
rects[[j]] <- st_polygon(list(validRects[[j]]))
}
merged_rects <- st_sfc(rects) %>% st_cast("POLYGON") %>% st_union()
# merged_rects <- merged_rects + c(minX,minY)
sf <- st_sfc(merged_rects)
return(sf)
} else { # Case 2: Nothing to show
sf <- st_sfc(st_polygon())
return(sf)
}
}
test <- findBuildable(testpoly3)
plot(test)
lines(testpoly3)
eqscplot(testpoly3)
eqscplot(testpoly3, type='l')
eqscplot(rbind(testpoly3,testpoly3[1,]), type='l')
plot(test)
lines(testpoly3)
testhole <- cbind(c(35,65,65,35),c(35,65,65,35))
test <- findBuildable(testpoly3, testhole)
testhole <- cbind(c(35,65,65,35),c(35,35,65,65))
test <- findBuildable(testpoly3, testhole)
