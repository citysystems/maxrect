test <- filter(full_json_data, APN %in% apn)
library(dplyr)
test <- filter(full_json_data, APN %in% apn)
View(test)
test <- filter(full_json_data, APN %in% apn)
library(maxrectangle)
library(jsonlite)
library(readr)
library(MASS)
library(sp)
json_file <- "epaparcelsnobldg.json"
full_json_data <- fromJSON(txt=json_file, flatten = TRUE, simplifyDataFrame = TRUE)
apn_file <- "apn.csv"
apn <- read_csv(apn_file)
apn <- paste( "0", apn$apn, sep = "")
test <- dplyr::filter(full_json_data, APN %in% apn)
full_json_data <- dplyr::filter(full_json_data, APN %in% apn)
json_data <- full_json_data$json_geometry.coordinates
len_json <- length(json_data)
View(json_data)
View(json_data)
?vector()
test <- vector(mode = "double", length = length(json_data))
for (i in 1:length(json_data)){
if (typeof(json_data[[i]]) == "list"){
test[i] <- length(json_data[[i]])
} else if (typeof(json_data[[i]]) == "double"){
test[i] <- dim(drop(json_data[[i]]))[1]
} else {
test[i] <- 0
}
}
summary(test)
str(test)
for (i in 1:length(json_data)){
if (typeof(json_data[[i]]) == "list"){
test[i] <- length(json_data[[i]])
} else if (typeof(json_data[[i]]) == "double"){
test[i] <- dim(json_data[[i]])[1]
} else {
test[i] <- 0
}
}
count(test)
table(test)
json_block <- "epaparcels_dissolved/epaparcels_dissolved_adj.geojson"
json_block_data <- fromJSON(txt=json_block, flatten = TRUE, simplifyDataFrame = TRUE, simplifyMatrix = TRUE)
json_block_data <- json_block_data$features$geometry.coordinates[[1]]
json_block_length <- 0
for(i in 1:length(json_block_data)){
json_block_data[[i]] <- drop(json_block_data[[i]])
json_block_length <- json_block_length + dim(json_block_data[[i]])[1]
}
jsonIndex <- 1
json_block_points <- array(data = 0, dim = c(json_block_length, 2))
for(i in 1:length(json_block_data)){
for(j in 1:dim(json_block_data[[i]])[1]){
json_block_points[jsonIndex,] <- json_block_data[[i]][j,]
jsonIndex <- jsonIndex + 1
}
}
json_block_points <- json_block_points[order( json_block_points[,1], json_block_points[,2]),]
# Find number of landlocked parcels (all points are touching another parcel)
# First, pull all the coordinates for the first polygon for each parcel
checkFront <- vector(mode = "logical", len_json)
json_data[[3]][1,,]
for (i in 1:len_json){
if (typeof(json_data[[i]]) == "list"){
poly <- json_data[[i]][[1]]
}
else if (typeof(json_data[[i]]) == "double"){
poly <- json_data[[i]][1,,]
}
for (j in 1:dim(poly)[1]){
if (isFront1(poly[j,])){
checkFront[i] <- TRUE
next
}
}
}
# Check if point is at front
# Inputs one point (x, y coordinate 1 x 2 vector)
# Outputs a boolean
isFront1 <- function(point){
# Check if point matches json_block_data
index <- findInterval(point[1], json_block_points[,1])
while(isTRUE(all.equal(point[1], json_block_points[index,1]))){         # search all coordinates w/ same X coord
if(isTRUE(all.equal(point[2], json_block_points[index,2]))){return(TRUE)}
index <- index + 1
}
return(FALSE)
}
checkFront <- vector(mode = "logical", len_json)
for (i in 1:len_json){
if (typeof(json_data[[i]]) == "list"){
poly <- json_data[[i]][[1]]
}
else if (typeof(json_data[[i]]) == "double"){
poly <- json_data[[i]][1,,]
}
for (j in 1:dim(poly)[1]){
if (isFront1(poly[j,])){
checkFront[i] <- TRUE
next
}
}
}
test <- json_data[[3]][1,,]
test[1,]
test[1]
test[2]
for (i in 1:len_json){
print(i)
if (typeof(json_data[[i]]) == "list"){
poly <- json_data[[i]][[1]]
}
else if (typeof(json_data[[i]]) == "double"){
poly <- json_data[[i]][1,,]
}
for (j in 1:dim(poly)[1]){
if (isFront1(poly[j,])){
checkFront[i] <- TRUE
next
}
}
}
test <- json_data[[80]][[1]]
# Find number of landlocked parcels (all points are touching another parcel)
# First, pull all the coordinates for the first polygon for each parcel
checkFront <- vector(mode = "logical", len_json)
for (i in 1:len_json){
print(i)
if (typeof(json_data[[i]]) == "list"){
poly <- drop(json_data[[i]][[1]])
}
else if (typeof(json_data[[i]]) == "double"){
poly <- json_data[[i]][1,,]
}
for (j in 1:dim(poly)[1]){
if (isFront1(poly[j,])){
checkFront[i] <- TRUE
next
}
}
}
# Find number of landlocked parcels (all points are touching another parcel)
# First, pull all the coordinates for the first polygon for each parcel
checkFront <- vector(mode = "logical", len_json)
for (i in 1:len_json){
print(i)
if (typeof(json_data[[i]]) == "list"){
poly <- drop(json_data[[i]][[1]])
}
else if (typeof(json_data[[i]]) == "double"){
if (length(dim(json_data[[i]])) > 3){
poly <- drop(json_data[[i]])[1,,]
}
poly <- json_data[[i]][1,,]
}
for (j in 1:dim(poly)[1]){
if (isFront1(poly[j,])){
checkFront[i] <- TRUE
next
}
}
}
test <- drop(json_data[[230]])
View(json_data)
test[1,,]
# Find number of landlocked parcels (all points are touching another parcel)
# First, pull all the coordinates for the first polygon for each parcel
checkFront <- vector(mode = "logical", len_json)
for (i in 1:len_json){
print(i)
if (typeof(json_data[[i]]) == "list"){
poly <- drop(json_data[[i]][[1]])
}
else if (typeof(json_data[[i]]) == "double"){
if (length(dim(json_data[[i]])) > 3){
poly <- drop(json_data[[i]])[1,,]
}
else{poly <- json_data[[i]][1,,]}
}
for (j in 1:dim(poly)[1]){
if (isFront1(poly[j,])){
checkFront[i] <- TRUE
next
}
}
}
# Find number of landlocked parcels (all points are touching another parcel)
# First, pull all the coordinates for the first polygon for each parcel
checkFront <- vector(mode = "logical", len_json)
for (i in 1:len_json){
print(i)
if (typeof(json_data[[i]]) == "list"){
poly <- drop(json_data[[i]][[1]])
}
else if (typeof(json_data[[i]]) == "double"){
if (length(dim(json_data[[i]])) > 3){
poly <- drop(json_data[[i]])[1,,]
}
else{poly <- json_data[[i]][1,,]}
}
else{
break
}
for (j in 1:dim(poly)[1]){
if (isFront1(poly[j,])){
checkFront[i] <- TRUE
next
}
}
}
sum(checkFront)
View(checkFront)
numFront <- vector(mode = "double", len_json)
checkFront <- vector(mode = "logical", len_json)
numFront <- vector(mode = "double", len_json)
for (i in 1:len_json){
print(i)
if (typeof(json_data[[i]]) == "list"){
poly <- drop(json_data[[i]][[1]])
}
else if (typeof(json_data[[i]]) == "double"){
if (length(dim(json_data[[i]])) > 3){
poly <- drop(json_data[[i]])[1,,]
}
else{poly <- json_data[[i]][1,,]}
}
else{
break
}
for (j in 1:dim(poly)[1]){
if (isFront1(poly[j,])){
checkFront[i] <- TRUE
numFront[i] <- numFront[i] + 1
}
}
}
count(numFront[numFront > 0])
sum(numFront[numFront > 0])
length(numFront[numFront > 0])
length(numFront[numFront > 0])
length(numFront[numFront > 1])
length(numFront[numFront > 2])
length(numFront[numFront > 3])
View(numFront)
View(full_json_data)
View(json_data)
# Check if point is at front
# Inputs one point (x, y coordinate 1 x 2 vector)
# Outputs a boolean
isFront1 <- function(point){
# Check if point matches json_block_data
index <- findInterval(point[1], json_block_points[,1])
while(isTRUE(all.equal(point[1], json_block_points[index,1], tolerance = 0.1))){         # search all coordinates w/ same X coord
if(isTRUE(all.equal(point[2], json_block_points[index,2], tolerance = 0.1))){return(TRUE)}
index <- index + 1
}
return(FALSE)
}
checkFront <- vector(mode = "logical", len_json)
numFront <- vector(mode = "double", len_json)
for (i in 1:len_json){
print(i)
if (typeof(json_data[[i]]) == "list"){
poly <- drop(json_data[[i]][[1]])
}
else if (typeof(json_data[[i]]) == "double"){
if (length(dim(json_data[[i]])) > 3){
poly <- drop(json_data[[i]])[1,,]
}
else{poly <- json_data[[i]][1,,]}
}
else{
break
}
for (j in 1:dim(poly)[1]){
if (isFront1(poly[j,])){
checkFront[i] <- TRUE
numFront[i] <- numFront[i] + 1
}
}
}
sum(checkFront)
# Check if point is at front
# Inputs one point (x, y coordinate 1 x 2 vector)
# Outputs a boolean
isFront1 <- function(point){
# Check if point matches json_block_data
index <- findInterval(point[1], json_block_points[,1])
while(isTRUE(all.equal(point[1], json_block_points[index,1], tolerance = 0.001))){         # search all coordinates w/ same X coord
if(isTRUE(all.equal(point[2], json_block_points[index,2], tolerance = 0.001))){return(TRUE)}
index <- index + 1
}
return(FALSE)
}
checkFront <- vector(mode = "logical", len_json)
numFront <- vector(mode = "double", len_json)
for (i in 1:len_json){
# print(i)
if (typeof(json_data[[i]]) == "list"){
poly <- drop(json_data[[i]][[1]])
}
else if (typeof(json_data[[i]]) == "double"){
if (length(dim(json_data[[i]])) > 3){
poly <- drop(json_data[[i]])[1,,]
}
else{poly <- json_data[[i]][1,,]}
}
else{
break
}
for (j in 1:dim(poly)[1]){
if (isFront1(poly[j,])){
checkFront[i] <- TRUE
numFront[i] <- numFront[i] + 1
}
}
}
sum(checkFront)
json_block_points[1,1]
# Check if point is at front
# Inputs one point (x, y coordinate 1 x 2 vector)
# Outputs a boolean
isFront1 <- function(point){
# Check if point matches json_block_data
index <- findInterval(point[1], json_block_points[,1])
while(isTRUE(all.equal(point[1], json_block_points[index,1], tolerance = 1e-5))){         # search all coordinates w/ same X coord
if(isTRUE(all.equal(point[2], json_block_points[index,2], tolerance = 1e-5))){return(TRUE)}
index <- index + 1
}
return(FALSE)
}
checkFront <- vector(mode = "logical", len_json)
numFront <- vector(mode = "double", len_json)
for (i in 1:len_json){
# print(i)
if (typeof(json_data[[i]]) == "list"){
poly <- drop(json_data[[i]][[1]])
}
else if (typeof(json_data[[i]]) == "double"){
if (length(dim(json_data[[i]])) > 3){
poly <- drop(json_data[[i]])[1,,]
}
else{poly <- json_data[[i]][1,,]}
}
else{
break
}
for (j in 1:dim(poly)[1]){
if (isFront1(poly[j,])){
checkFront[i] <- TRUE
numFront[i] <- numFront[i] + 1
}
}
}
# Check if point is at front
# Inputs one point (x, y coordinate 1 x 2 vector)
# Outputs a boolean
isFront1 <- function(point){
# Check if point matches json_block_data
index <- findInterval(point[1], json_block_points[,1])
while(isTRUE(all.equal(point[1], json_block_points[index,1], tolerance = 1e-5))){         # search all coordinates w/ same X coord
if(isTRUE(all.equal(point[2], json_block_points[index,2], tolerance = 1e-5))){return(TRUE)}
index <- index + 1
}
return(FALSE)
}
checkFront <- vector(mode = "logical", len_json)
numFront <- vector(mode = "double", len_json)
for (i in 1:len_json){
checkFront <- vector(mode = "logical", len_json)
numFront <- vector(mode = "double", len_json)
for (i in 1:len_json){
# print(i)
if (typeof(json_data[[i]]) == "list"){
poly <- drop(json_data[[i]][[1]])
}
else if (typeof(json_data[[i]]) == "double"){
if (length(dim(json_data[[i]])) > 3){
poly <- drop(json_data[[i]])[1,,]
}
else{poly <- json_data[[i]][1,,]}
}
else{
break
}
for (j in 1:dim(poly)[1]){
if (isFront1(poly[j,])){
checkFront[i] <- TRUE
numFront[i] <- numFront[i] + 1
}
}
}
isFront1 <- function(point){
# Check if point matches json_block_data
index <- findInterval(point[1], json_block_points[,1])
while(isTRUE(all.equal(point[1], json_block_points[index,1], tolerance = 1e-5))){         # search all coordinates w/ same X coord
if(isTRUE(all.equal(point[2], json_block_points[index,2], tolerance = 1e-5))){return(TRUE)}
index <- index + 1
}
return(FALSE)
}
checkFront <- vector(mode = "logical", len_json)
numFront <- vector(mode = "double", len_json)
for (i in 1:len_json){
print(i)
if (typeof(json_data[[i]]) == "list"){
poly <- drop(json_data[[i]][[1]])
}
else if (typeof(json_data[[i]]) == "double"){
if (length(dim(json_data[[i]])) > 3){
poly <- drop(json_data[[i]])[1,,]
}
else{poly <- json_data[[i]][1,,]}
}
else{
break
}
for (j in 1:dim(poly)[1]){
if (isFront1(poly[j,])){
checkFront[i] <- TRUE
numFront[i] <- numFront[i] + 1
}
}
}
sum(checkFront)
length(numFront[numFront > 0])
length(numFront[numFront > 1])
length(numFront[numFront > 2])
length(numFront[numFront > 3])
View(numFront)
View(json_data)
View(full_json_data)
landlocked <- vector("logical", len_json)
landlocked <- vector("logical", sum(checkFront))
index <- 1
for (i in 1:len_json){
if (!checkFront){
landlocked[index] <- i
index <- index + 1
}
}
warnings()
landlocked <- vector("logical", sum(checkFront))
index <- 1
for (i in 1:len_json){
if (!checkFront[i]){
landlocked[index] <- i
index <- index + 1
}
}
full_json_data$APN[[1]]
landlockedAPNs <- vector("logical", sum(checkFront))
for (i in 1:sum(checkFront)){
landlockedAPNs <- full_json_data$APN[[landlocked[i]]]
}
landlockedAPNs <- vector("logical", sum(checkFront))
for (i in 1:sum(checkFront)){
landlockedAPNs <- full_json_data$APN[[landlocked[i]]]
}
landlockedAPNs <- vector("logical", sum(checkFront))
for (i in 1:sum(checkFront)){
landlockedAPNs[i] <- full_json_data$APN[[landlocked[i]]]
}
landlockedAPNs <- vector("logical", sum(checkFront))
for (i in 1:sum(checkFront)){
print(i)
landlockedAPNs[i] <- full_json_data$APN[[landlocked[i]]]
}
View(landlocked)
landlocked <- vector("logical", len_json - sum(checkFront))
index <- 1
for (i in 1:len_json){
if (!checkFront[i]){
landlocked[index] <- i
index <- index + 1
}
}
landlockedAPNs <- vector("logical", len_json - sum(checkFront))
for (i in 1:len_json - sum(checkFront)){
print(i)
landlockedAPNs[i] <- full_json_data$APN[[landlocked[i]]]
}
landlocked <- vector("logical", len_json - sum(checkFront))
index <- 1
for (i in 1:len_json){
if (!checkFront[i]){
landlocked[index] <- i
index <- index + 1
}
}
landlockedAPNs <- vector("logical", len_json - sum(checkFront))
for (i in 1:(len_json - sum(checkFront))){
print(i)
landlockedAPNs[i] <- full_json_data$APN[[landlocked[i]]]
}
View(landlockedAPNs)
?write_csv()
write_csv(landlockedAPNs, "landlockedAPNs.csv")
write_csv(as.data.frame(landlockedAPNs), "landlockedAPNs.csv")
View(full_json_data)
View(full_json_data)
View(json_data)
eqscplot(json_data[[65]][[1]], type="l")
points(json_block_points)
eqscplot(json_block_points)
eqscplot(json_data[[65]][[1]], type="l")
eqscplot(json_data[[65]][[1]])
points(json_block_points)
