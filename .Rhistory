all_merged_rings[[a]] <- merge_rings(ring1,ring2)
# all_merged_rings[[a]] <- 1
}
else if (dim(arr)[2] == 2){    # if is just one polygon, return that polygon
all_merged_rings[[a]] <- arr
}
else {
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "nonconforming array"
jsonIndex <- jsonIndex + 1
}
}
else if (typeof(json_data[[a]]) == "list") {
if (length(json_data[[a]]) == 2){ # if list has length 2
if(xor(typeof(json_data[[a]][[1]]) == "list", typeof(json_data[[a]][[2]]) == "list")){ # get rid of nested list cases
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "nested list"
jsonIndex <- jsonIndex + 1
}
else if (typeof(json_data[[a]][[1]]) == "list" && typeof(json_data[[a]][[2]]) == "list"){ # both lists
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "two lists"
jsonIndex <- jsonIndex + 1
}
else{
arr1 <- drop(arr[[1]])
arr2 <- drop(arr[[2]])
if(dim(arr1)[2] == 2 && dim(arr2)[2] == 2){
ring1 <- arr1
ring2 <- arr2
all_merged_rings[[a]] <- merge_rings(ring1,ring2)
# all_merged_rings[[a]] <- 2
}
}
}
else if (length(json_data[[a]]) > 2){
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "more than 2 things in list"
}
else{
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "other error"
jsonIndex <- jsonIndex + 1
}
}
}
View(manualJSON)
all_merged_rings <- vector("list", len_json)
manualJSON <- array(dim = c(len_json, 2))
jsonIndex <- 1
for(a in 1:len_json) {
all_merged_rings[[a]] <- NA
# Check the type of data: double (aka array) or list
arr <- drop(json_data[[a]]) # gets rid of dimensions of 1 length
if (typeof(json_data[[a]]) == "double") { # is an array [a x b x c]
if(dim(arr)[1] == 2 && dim(arr)[3] == 2) { # if array is [2 x b x 2]
ring1 <- arr[1,,]
ring2 <- arr[2,,]
all_merged_rings[[a]] <- merge_rings(ring1,ring2)
# all_merged_rings[[a]] <- 1
}
else if (dim(arr)[2] == 2){    # if is just one polygon, return that polygon
all_merged_rings[[a]] <- arr
}
else {
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "nonconforming array"
jsonIndex <- jsonIndex + 1
}
}
else if (typeof(json_data[[a]]) == "list") {
if (length(json_data[[a]]) == 2){ # if list has length 2
if(xor(typeof(json_data[[a]][[1]]) == "list", typeof(json_data[[a]][[2]]) == "list")){ # get rid of nested list cases
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "nested list"
jsonIndex <- jsonIndex + 1
}
else if (typeof(json_data[[a]][[1]]) == "list" && typeof(json_data[[a]][[2]]) == "list"){ # both lists
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "two lists"
jsonIndex <- jsonIndex + 1
}
else{
arr1 <- drop(arr[[1]])
arr2 <- drop(arr[[2]])
if(dim(arr1)[2] == 2 && dim(arr2)[2] == 2){
ring1 <- arr1
ring2 <- arr2
all_merged_rings[[a]] <- merge_rings(ring1,ring2)
# all_merged_rings[[a]] <- 2
}
}
}
else if (length(json_data[[a]]) > 2){
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "more than 2 things in list"
jsonIndex <- jsonIndex + 1
}
else{
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "other error"
jsonIndex <- jsonIndex + 1
}
}
}
View(manualJSON)
summary(manualJSON)
saveErrors <- manualJSON
View(json_data)
?local()
unpackList <-local({
function(lst) {
len <- length(lst)    # get length of list
for(i in 1:len){       # go through list
# check if element is a list or array
if (typeof(lst[[i]]) == "list"){
if (i == 1){ result <- unpackList(lst[[i]])}               # if first element, initialize result, recursively call function
else{result <- merge_rings(result, unpackList(lst[[i]]))} # if not, merge onto existing result, recursively call function
} else if (typeof(lst[[i]]) == "double"){
arr <- drop(lst[[i]])
if (length(dim(arr)) == 2 && dim(arr)[2] == 2){   # check that array has R x 2 dimensions
if (i == 1){return(arr)}                            # if first element, initialize result
else{return(merge_rings(result, arr))}               # if not, merge onto existing result
}
} else{
print("Error")
return()
}
}
}
})
View(json_data)
merged_rings(json_data[[4]][[1]],json_data[[4]][[2]])
test <- merge_rings(json_data[[4]][[1]],json_data[[4]][[2]])
View(test)
View(test)
?append()
append(test, test)
test2 <- append(test, test)
View(test2)
list()
test3 <- append(list(),test)
View(test3)
test <- list()
merge_rings <- function(ringA, ringB){
result <- list()
if (typeof(ringA) == "list"){
indexA <- length(ringA)
} else{indexA <- 1}
if (typeof(ringB) == "list"){
indexB <- length(ringB)
} else{indexB <- 1}
# Case 1: ringA is a list, ringB is an array
if (indexA > 1 && indexB == 1){   #check if there are any lists
for(j in 1:indexA){
result <- append(result, merge_rings(ringA[[j]], ringB))
}
}
# Case 2: ringB is a list, ringA is an array
else if (indexA == 1 && indexB > 1){
for(k in 1:indexB){
result <- append(result, merge_rings(ringA, ringB[[k]]))
}
}
# Case 3: ringA and ringB are both lists
else if (indexA > 1 && indexB > 1){
for(j in 1:indexA){
for(k in 1:indexB){
result <- append(result, merge_rings(ringA[[j]], ringB[[k]]))
}
}
}
# Base Case: ringA and ringB are arrays
# ring2 is the polygon with fewer points
# ring1 is the polygon with more points
else{
if (length(ringA[,1]) <= length(ringB[,1])){
ring2 <- ringA
ring1 <- ringB
} else {
ring1 <- ringA
ring2 <- ringB
}
len_r1 <- length(ring1[,1])-1  #don't need to consider last point, which is the same as point 1
len_r2 <- length(ring2[,1])-1  #don't need to consider last point, which is the same as point 1
# find all pairs of closest points
ring2_closest <- vector("double", len_r2)
# cycle through each ring1 point
for(m in 1:len_r2){
#returns index of closest ring2 point to current ring1 point
min_dist <- 1e99 #start with a very high number
min_index <- 0   #start with index 0 (not in the index)
for (n in 1:len_r1) {
dx <- abs(ring2[m,1]-ring1[n,1])
dy <- abs(ring2[m,2]-ring1[n,2])
dist <- sqrt(dx*dx+dy*dy)
if (dist < min_dist) {
min_dist <- dist
min_index <- n
}
}
# saves index of closest ring2 point
ring2_closest[m] <- min_index
}
result <- vector("list", len_r2)
for(i in 1:len_r2){
# merge rings for 1 iteration
ring_merge <- cbind(vector("double", len_r1+len_r2+3),vector("double", len_r1+len_r2+3))
index_merge <- 1   # keep track of index in ring_merge
index2 <- i        # keep track of index in ring2
# add ring1 to ring_merge
for(m in 1:len_r2){
ring_merge[index_merge,1] <- ring2[index2,1]  # transfer value
ring_merge[index_merge,2] <- ring2[index2,2]  # transfer value
index2 <- index2 %% len_r2 + 1 #increment, if at end of index, loops back to 1
index_merge <- index_merge + 1 #increment, no need to loop back
}
#add last point to close ring2
ring_merge[index_merge,1] <- ring2[index2,1]
ring_merge[index_merge,2] <- ring2[index2,2]
index_merge <- index_merge + 1
#add ring2 to ring_merge
index1 <- ring2_closest[index2]
for(n in 1:len_r1){
ring_merge[index_merge,1] <- ring1[index1,1]  # transfer value
ring_merge[index_merge,2] <- ring1[index1,2]  # transfer value
index1 <- index1 - 1 #increment, if at end of index, loops back to 1
if (index1 == 0) {index1 <- len_r1}
index_merge <- index_merge + 1 #increment, no need to loop back
}
ring_merge[index_merge,1] <- ring1[index1,1]
ring_merge[index_merge,2] <- ring1[index1,2]
index_merge <- index_merge + 1
ring_merge[index_merge,1] <- ring2[index2,1]
ring_merge[index_merge,2] <- ring2[index2,2]
result[[i]] <- ring_merge
}
return(result)
}
return(result)
}
test <- unpackList(json_data[[2]])
View(test)
View(json_data[[2]])
unpackList <-local({
function(lst) {
len <- length(lst)    # get length of list
if(typeof(lst[[1]]) == "list"){
result <- unpackList(lst[[i]])  # initialize result, recursively call function
} else if (typeof(lst[[1]]) == "double"){
arr <- drop(lst[[1]])
if (length(dim(arr)) == 2 && dim(arr)[2] == 2){   # check that array has R x 2 dimensions
result <- arr
}
} else{
print("Error")
return()
}
for(i in 2:len){       # go through list
# check if element is a list or array
if (typeof(lst[[i]]) == "list"){
result <- merge_rings(result, unpackList(lst[[i]])) # merge onto existing result, recursively call function
} else if (typeof(lst[[i]]) == "double"){
arr <- drop(lst[[i]])
if (length(dim(arr)) == 2 && dim(arr)[2] == 2){   # check that array has R x 2 dimensions
return(merge_rings(result, arr))                # merge onto existing result
}
} else{
print("Error")
return()
}
}
}
})
test <- unpackList(json_data[[2]])
View(test)
View(test)
eqscplot(test)
eqscplot(test, type= "l")
eqscplot(test[[1]], type= "l")
eqscplot(json_data[[2]][[1]])
eqscplot(json_data[[2]][[1]], type= "l")
lines(json_data[[2]][[2]])
lines(json_data[[2]][[3]])
lines(json_data[[2]][[4]])
unpackList <-local({
function(lst) {
len <- length(lst)    # get length of list
if(typeof(lst[[1]]) == "list"){
result <- unpackList(lst[[1]])  # initialize result, recursively call function
} else if (typeof(lst[[1]]) == "double"){
arr <- drop(lst[[1]])
if (length(dim(arr)) == 2 && dim(arr)[2] == 2){   # check that array has R x 2 dimensions
result <- arr
}
} else{
print("Error")
return()
}
for(i in 2:len){       # go through list
# check if element is a list or array
if (typeof(lst[[i]]) == "list"){
result <- merge_rings(result, unpackList(lst[[i]])) # merge onto existing result, recursively call function
} else if (typeof(lst[[i]]) == "double"){
arr <- drop(lst[[i]])
if (length(dim(arr)) == 2 && dim(arr)[2] == 2){   # check that array has R x 2 dimensions
result <- merge_rings(result, arr)                # merge onto existing result
}
} else{
print("Error")
return()
}
}
return(result)
}
})
test <- unpackList(json_data[[2]])
View(test)
View(test)
eqscplot(test[[1]], type= "l")
ctx <- initjs()
lr = find_lr(ctx, test[[1])
lr = find_lr(ctx, test[[1]])
pp = plotrect(lr[[1]])
ctx <- initjs()
lr = find_lr(ctx, test[[1]])
eqscplot(test[[2]], type= "l")
eqscplot(test[[1]], type= "l")
eqscplot(test[[3]], type= "l")
eqscplot(test[[4]], type= "l")
ctx <- initjs()
lr = find_lr(ctx, test[[4]])
eqscplot(json_data[[31]][[1]], type= "l")
lines(json_data[[31]][[2]])
lines(json_data[[31]][[3]])
test <- unpackList(json_data[[31]])
View(test)
eqscplot(test[[1]], type= "l")
eqscplot(test[[1]], type= "l")
ctx <- initjs()
eqscplot(test[[2]], type= "l")
lr = find_lr(ctx, test[[2]])
pp = plotrect(lr[[1]])
lines(pp)
poly <- prepPoly(test[[2]])[[1]]
eqscplot(poly, type= "l")
ctx <- initjs()
lr = find_lr(ctx, poly)
pp = plotrect(lr[[1]])
lines(pp)
test <- unpackList(json_data[[4]])
View(test)
View(test)
all_merged_rings <- vector("list", len_json)
manualJSON <- array(dim = c(len_json, 2))
jsonIndex <- 1
for(a in 1:len_json) {
all_merged_rings[[a]] <- NA
# Check the type of data: double (aka array) or list
arr <- drop(json_data[[a]]) # gets rid of dimensions of 1 length
if (typeof(json_data[[a]]) == "double") { # is an array [a x b x c]
if(dim(arr)[1] == 2 && dim(arr)[3] == 2) { # if array is [2 x b x 2]
ring1 <- arr[1,,]
ring2 <- arr[2,,]
all_merged_rings[[a]] <- merge_rings(ring1,ring2)
# all_merged_rings[[a]] <- 1
}
else if (dim(arr)[2] == 2){    # if is just one polygon, return that polygon
all_merged_rings[[a]] <- arr
}
else {
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "nonconforming array"
jsonIndex <- jsonIndex + 1
}
}
else if (typeof(json_data[[a]]) == "list") {
all_merged_rings[[a]] <- unpackList(json_data[[a]])
}
else{
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "other error"
jsonIndex <- jsonIndex + 1
}
}
all_merged_rings <- vector("list", len_json)
manualJSON <- array(dim = c(len_json, 2))
jsonIndex <- 1
for(a in 1:len_json) {
all_merged_rings[[a]] <- NA
print(a)
# Check the type of data: double (aka array) or list
arr <- drop(json_data[[a]]) # gets rid of dimensions of 1 length
if (typeof(json_data[[a]]) == "double") { # is an array [a x b x c]
if(dim(arr)[1] == 2 && dim(arr)[3] == 2) { # if array is [2 x b x 2]
ring1 <- arr[1,,]
ring2 <- arr[2,,]
all_merged_rings[[a]] <- merge_rings(ring1,ring2)
# all_merged_rings[[a]] <- 1
}
else if (dim(arr)[2] == 2){    # if is just one polygon, return that polygon
all_merged_rings[[a]] <- arr
}
else {
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "nonconforming array"
jsonIndex <- jsonIndex + 1
}
}
else if (typeof(json_data[[a]]) == "list") {
all_merged_rings[[a]] <- unpackList(json_data[[a]])
}
else{
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "other error"
jsonIndex <- jsonIndex + 1
}
}
eqscplot(json_data[[1417]][[1]], type= "l")
eqscplot(json_data[[1417]][[2]], type= "l")
eqscplot(json_data[[1417]][[1]], type= "l")
all_merged_rings <- vector("list", len_json)
manualJSON <- array(dim = c(len_json, 2))
jsonIndex <- 1
for(a in 1:len_json) {
all_merged_rings[[a]] <- NA
print(a)
# Check the type of data: double (aka array) or list
arr <- drop(json_data[[a]]) # gets rid of dimensions of 1 length
if (typeof(json_data[[a]]) == "double") { # is an array [a x b x c]
if(dim(arr)[1] == 2 && dim(arr)[3] == 2) { # if array is [2 x b x 2]
ring1 <- arr[1,,]
ring2 <- arr[2,,]
all_merged_rings[[a]] <- merge_rings(ring1,ring2)
# all_merged_rings[[a]] <- 1
}
else if (dim(arr)[2] == 2){    # if is just one polygon, return that polygon
all_merged_rings[[a]] <- arr
}
else {
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "nonconforming array"
jsonIndex <- jsonIndex + 1
}
}
else if (typeof(json_data[[a]]) == "list") {
if (length(json_data[[a]] > 5)){
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "long list"
} else{all_merged_rings[[a]] <- unpackList(json_data[[a]])}
}
else{
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "other error"
jsonIndex <- jsonIndex + 1
}
}
all_merged_rings <- vector("list", len_json)
manualJSON <- array(dim = c(len_json, 2))
jsonIndex <- 1
for(a in 1:len_json) {
all_merged_rings[[a]] <- NA
print(a)
# Check the type of data: double (aka array) or list
arr <- drop(json_data[[a]]) # gets rid of dimensions of 1 length
if (typeof(json_data[[a]]) == "double") { # is an array [a x b x c]
if(dim(arr)[1] == 2 && dim(arr)[3] == 2) { # if array is [2 x b x 2]
ring1 <- arr[1,,]
ring2 <- arr[2,,]
all_merged_rings[[a]] <- merge_rings(ring1,ring2)
# all_merged_rings[[a]] <- 1
}
else if (dim(arr)[2] == 2){    # if is just one polygon, return that polygon
all_merged_rings[[a]] <- arr
}
else {
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "nonconforming array"
jsonIndex <- jsonIndex + 1
}
}
else if (typeof(json_data[[a]]) == "list") {
if (length(json_data[[a]]) > 5){
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "long list"
} else{all_merged_rings[[a]] <- unpackList(json_data[[a]])}
}
else{
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "other error"
jsonIndex <- jsonIndex + 1
}
}
flip_order <- function(array, start, end){
copy <- array(0, dim=c(end - start + 1, 2))
for(n in 1:(end-start+1)){
copy[n,] <- array[start+n-1,]
}
copy <- copy[nrow(copy):1,]
for(n in 1:(end-start+1)){
array[start + n - 1,1] <-  copy[n,1]
array[start + n - 1,2] <-  copy[n,2]
}
return(array)
}
View(manualJSON)
View(json_data[[5036]])
View(json_data[[260]])
dim(json_data[[704]])
dim(json_data[[260]])
dim(json_data[[970]])
save.image()
