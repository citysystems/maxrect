}
}
}
rectOptions <- compact(rectOptions)  # Remove null entries
## print(maxRect)
## print(maxArea)
## print(rectOptions)
return (list(maxRect, maxArea, rectOptions))
}
lr <- largestRect(st_geometry(result_Bldg0[i,]),result_Bldg0$slopes[i])
# Input: st_polygon. May contain holes, need to separate those out
largestRect <- function(polygon, angles = NULL){
## For keeping all the buildable area
rectOptions <- vector("list", 10000)
##### User's input normalization #####
aspectRatioStep <- 0.1
angleStep <- 5
maxAspectRatio <- 15
minWidth <- 8
minHeight <- 20
# tolerance <- 0.02
nTries <- 100
# Angles
if (is.null(angles)){
angles <- seq(-90, 90+angleStep, angleStep)*pi/180
}
else{ # Add all possible "square" orientations for each angle (e.g. 45, 135, -45, -135)
angles <- unlist(angles)
angles <- unique(c(angles,
angles + pi/2,
angles + pi,
angles - pi/2
))
angles <- angles %% (2*pi) %>% sort() %>% unique()
}
## print(angles)
##########################################
area <- st_area(polygon)
# Simple case: just one polygon, no hole, not closed
coord <- as_tibble(st_coordinates(polygon))
poly1 <- (coord %>% filter(L1 == 1) %>% select(X, Y))[-1,] %>% unlist() %>% unname() %>% matrix(ncol = 2)
poly2 <- NULL
if (mean(coord$L1) > 1){
poly2 <- (coord %>% filter(L1 == 2) %>% select(X, Y))[-1,] %>% unlist() %>% unname() %>% matrix(ncol = 2)
}
## print(poly1)
## print(poly2)
# get the width of the bounding box of the original polygon to determine tolerance
minx <- min(poly1[,1])
miny <- min(poly1[,2])
maxx <- max(poly1[,1])
maxy <- max(poly1[,2])
bBox <- rbind(c(minx, miny), c(maxx, miny), c(maxx, maxy), c(minx, maxy))
boxWidth <- maxx - minx
boxHeight <- maxy - miny
# discretize the binary search for optimal width to a resolution of this times the polygon width
widthStep <-  min(boxWidth, boxHeight)/100
# populate possible center points with random points inside the polygon
origins <- array(dim = c(0,2))
# get the centroid of the polygon
centroid <- st_coordinates(st_centroid(polygon)) %>% as.vector()
if (pointInPoly(centroid, poly1) && !pointInPoly(centroid, poly2)){
origins <- rbind(origins, centroid)
}
# get few more points inside the polygon
while (nrow(origins) < nTries){
rndX <- runif(1) * boxWidth + minx
rndY <- runif(1) * boxHeight + miny
rndPoint <- c(rndX, rndY)
if (pointInPoly(rndPoint, poly1) && !pointInPoly(rndPoint, poly2)){
origins <- rbind(origins, rndPoint)
}
}
## print(origins)
maxArea <- 0
maxRect <- NULL
rectOptions_i <- 1
iterMaxRect <- NULL
# Mother of for loops
for (i in 1:length(angles)){
## print(paste0("i =", i))
angleRad <- angles[i]
for (j in 1:nrow(origins)){
## print(paste0("j =", j))
origOrigin <- origins[j,]
origW <- intersectPoints(poly1, origOrigin, angleRad)
## print(paste0("origW =", origW))
p1W <- origW[1,]
tryCatch({p2W <- origW[2,]}, error = function(e){print(origW)})
origH <- intersectPoints(poly1, origOrigin, angleRad + pi/2)
## print(paste0("origH =", origH))
p1H <- origH[1,]
tryCatch({p2H <- origH[2,]}, error = function(e){print(origH)})
modifOrigins <- rbind(colMeans(origW), colMeans(origH)) # Two modified origins, using center of horizontal and verticle ray segments
## print(paste0("modifOrigins =", modifOrigins))
iterMaxArea <- 0
for (k in 1:nrow(modifOrigins)){
## print(paste0("k =", k))
origin <- modifOrigins[k,]
W <- intersectPoints(poly1, origin, angleRad)
## print(paste0("W =", W))
minSqDistW <- min(squaredDist(origin, W[1,]), squaredDist(origin, W[2,]))
maxWidth <- 2*sqrt(minSqDistW)
## print(paste0("maxWidth =", maxWidth))
H <- intersectPoints(poly1, origin, angleRad + pi/2)
## print(paste0("H =", H))
minSqDistH <- min(squaredDist(origin, H[1,]), squaredDist(origin, H[2,]))
maxHeight <- 2*sqrt(minSqDistH)
## print(paste0("maxHeight =", maxHeight))
minAspectRatio <- max(1, minWidth/maxHeight)
maxAspectRatio <- max(min(maxAspectRatio, maxWidth/minHeight),1)
if (minAspectRatio > maxAspectRatio){
aRatios <- minAspectRatio
}else{
aRatios <- seq(abs(minAspectRatio), abs(maxAspectRatio + aspectRatioStep), abs(aspectRatioStep))
}
## print(paste0("aRatios =", aRatios))
for (l in 1:length(aRatios)){
## print(paste0("l =", l))
aRatio <- aRatios[l]
# do a binary search to find the max width that works
left <- minWidth
right <- min(maxWidth, maxHeight*aRatio)
while ((right - left) >= widthStep){
width <- (left + right) / 2
height <- width / aRatio
x0 <- origin[1]
y0 <- origin[2]
rectPoly <- rbind(
c(x0 - width/2, y0 - height/2),
c(x0 + width/2, y0 - height/2),
c(x0 + width/2, y0 + height/2),
c(x0 - width/2, y0 + height/2)
)
## print(paste0("rectPoly =", rectPoly))
rectPoly <- rotatePoly(rectPoly, angleRad, origin)
## print(paste0("Rotated rectPoly =", rectPoly))
# (1) rectPoly does not intersect with both poly1 and poly2, (2) rectPoly is inside poly1, (3) rectPoly and poly2 are separate
if (!polyIntersect(rectPoly, poly1) && !polyIntersect(rectPoly, poly2) && polyInsidePoly(rectPoly, poly1) && !polyInsidePoly(rectPoly, poly2) && !polyInsidePoly(poly2, rectPoly)){
## print("rectPoly is inside poly")
insidePoly <- TRUE
if (width * height > iterMaxArea){
iterMaxArea <- width * height
rectPoly <- rbind(rectPoly, rectPoly[1,]) # close the polygon to export
iterMaxRect <- rectPoly
}
left <- width # increase the width in the binary search
# we know that the area is already greater than the maxArea found so far
if (width * height > maxArea){
## print("Max Area")
maxArea <- width * height
maxRect$cx <- x0
maxRect$cy <- y0
maxRect$width <- width
maxRect$height <- height
maxRect$angle
}
}
else{
insidePoly <- FALSE
right <- width
}
}
}
rectOptions[[rectOptions_i]] <- iterMaxRect
rectOptions_i <- rectOptions_i + 1
}
}
}
rectOptions <- compact(rectOptions)  # Remove null entries
## print(maxRect)
## print(maxArea)
## print(rectOptions)
return (list(maxRect, maxArea, rectOptions))
}
Q
Q
# Input: st_polygon. May contain holes, need to separate those out
largestRect <- function(polygon, angles = NULL){
## For keeping all the buildable area
rectOptions <- vector("list", 10000)
##### User's input normalization #####
aspectRatioStep <- 0.1
angleStep <- 5
maxAspectRatio <- 15
minWidth <- 8
minHeight <- 20
# tolerance <- 0.02
nTries <- 100
# Angles
if (is.null(angles)){
angles <- seq(-90, 90+angleStep, angleStep)*pi/180
}
else{ # Add all possible "square" orientations for each angle (e.g. 45, 135, -45, -135)
angles <- unlist(angles)
angles <- unique(c(angles,
angles + pi/2,
angles + pi,
angles - pi/2
))
angles <- angles %% (2*pi) %>% sort() %>% unique()
}
## print(angles)
##########################################
area <- st_area(polygon)
# Simple case: just one polygon, no hole, not closed
coord <- as_tibble(st_coordinates(polygon))
poly1 <- (coord %>% filter(L1 == 1) %>% select(X, Y))[-1,] %>% unlist() %>% unname() %>% matrix(ncol = 2)
poly2 <- NULL
if (mean(coord$L1) > 1){
poly2 <- (coord %>% filter(L1 == 2) %>% select(X, Y))[-1,] %>% unlist() %>% unname() %>% matrix(ncol = 2)
}
## print(poly1)
## print(poly2)
# get the width of the bounding box of the original polygon to determine tolerance
minx <- min(poly1[,1])
miny <- min(poly1[,2])
maxx <- max(poly1[,1])
maxy <- max(poly1[,2])
bBox <- rbind(c(minx, miny), c(maxx, miny), c(maxx, maxy), c(minx, maxy))
boxWidth <- maxx - minx
boxHeight <- maxy - miny
# discretize the binary search for optimal width to a resolution of this times the polygon width
widthStep <-  min(boxWidth, boxHeight)/100
# populate possible center points with random points inside the polygon
origins <- array(dim = c(0,2))
# get the centroid of the polygon
centroid <- st_coordinates(st_centroid(polygon)) %>% as.vector()
if (pointInPoly(centroid, poly1) && !pointInPoly(centroid, poly2)){
origins <- rbind(origins, centroid)
}
# get few more points inside the polygon
while (nrow(origins) < nTries){
rndX <- runif(1) * boxWidth + minx
rndY <- runif(1) * boxHeight + miny
rndPoint <- c(rndX, rndY)
if (pointInPoly(rndPoint, poly1) && !pointInPoly(rndPoint, poly2)){
origins <- rbind(origins, rndPoint)
}
}
## print(origins)
maxArea <- 0
maxRect <- NULL
rectOptions_i <- 1
iterMaxRect <- NULL
# Mother of for loops
for (i in 1:length(angles)){
## print(paste0("i =", i))
angleRad <- angles[i]
for (j in 1:nrow(origins)){
## print(paste0("j =", j))
origOrigin <- origins[j,]
origW <- intersectPoints(poly1, origOrigin, angleRad)
## print(paste0("origW =", origW))
p1W <- origW[1,]
tryCatch({p2W <- origW[2,]}, error = function(e){print(origW)})
origH <- intersectPoints(poly1, origOrigin, angleRad + pi/2)
## print(paste0("origH =", origH))
p1H <- origH[1,]
tryCatch({p2H <- origH[2,]}, error = function(e){print(origH)})
modifOrigins <- rbind(colMeans(origW), colMeans(origH)) # Two modified origins, using center of horizontal and verticle ray segments
## print(paste0("modifOrigins =", modifOrigins))
iterMaxArea <- 0
for (k in 1:nrow(modifOrigins)){
## print(paste0("k =", k))
origin <- modifOrigins[k,]
W <- intersectPoints(poly1, origin, angleRad)
## print(paste0("W =", W))
minSqDistW <- min(squaredDist(origin, W[1,]), squaredDist(origin, W[2,]))
maxWidth <- 2*sqrt(minSqDistW)
## print(paste0("maxWidth =", maxWidth))
H <- intersectPoints(poly1, origin, angleRad + pi/2)
## print(paste0("H =", H))
minSqDistH <- min(squaredDist(origin, H[1,]), squaredDist(origin, H[2,]))
maxHeight <- 2*sqrt(minSqDistH)
## print(paste0("maxHeight =", maxHeight))
minAspectRatio <- max(1, minWidth/maxHeight)
maxAspectRatio <- max(min(maxAspectRatio, maxWidth/minHeight),1)
if (minAspectRatio > maxAspectRatio){
aRatios <- minAspectRatio
}else{
aRatios <- seq(abs(minAspectRatio), abs(maxAspectRatio + aspectRatioStep), abs(aspectRatioStep))
}
## print(paste0("aRatios =", aRatios))
for (l in 1:length(aRatios)){
## print(paste0("l =", l))
aRatio <- aRatios[l]
# do a binary search to find the max width that works
left <- minWidth
right <- min(maxWidth, maxHeight*aRatio)
while ((right - left) >= widthStep){
width <- (left + right) / 2
height <- width / aRatio
x0 <- origin[1]
y0 <- origin[2]
rectPoly <- rbind(
c(x0 - width/2, y0 - height/2),
c(x0 + width/2, y0 - height/2),
c(x0 + width/2, y0 + height/2),
c(x0 - width/2, y0 + height/2)
)
## print(paste0("rectPoly =", rectPoly))
rectPoly <- rotatePoly(rectPoly, angleRad, origin)
## print(paste0("Rotated rectPoly =", rectPoly))
# (1) rectPoly does not intersect with both poly1 and poly2, (2) rectPoly is inside poly1, (3) rectPoly and poly2 are separate
if (!polyIntersect(rectPoly, poly1) && !polyIntersect(rectPoly, poly2) && polyInsidePoly(rectPoly, poly1) && !polyInsidePoly(rectPoly, poly2) && !polyInsidePoly(poly2, rectPoly)){
## print("rectPoly is inside poly")
insidePoly <- TRUE
if (width * height > iterMaxArea){
iterMaxArea <- width * height
rectPoly <- rbind(rectPoly, rectPoly[1,]) # close the polygon to export
iterMaxRect <- rectPoly
}
left <- width # increase the width in the binary search
# we know that the area is already greater than the maxArea found so far
if (width * height > maxArea){
## print("Max Area")
maxArea <- width * height
maxRect$cx <- x0
maxRect$cy <- y0
maxRect$width <- width
maxRect$height <- height
maxRect$angle
}
}
else{
insidePoly <- FALSE
right <- width
}
}
}
rectOptions[[rectOptions_i]] <- iterMaxRect
rectOptions_i <- rectOptions_i + 1
}
}
}
rectOptions <- compact(rectOptions)  # Remove null entries
## print(maxRect)
## print(maxArea)
## print(rectOptions)
return (list(maxRect, maxArea, rectOptions))
}
lr <- largestRect(st_geometry(result_Bldg0[i,]),result_Bldg0$slopes[i])
?try()
# Input: st_polygon. May contain holes, need to separate those out
largestRect <- function(polygon, angles = NULL){
## For keeping all the buildable area
rectOptions <- vector("list", 10000)
##### User's input normalization #####
aspectRatioStep <- 0.1
angleStep <- 5
maxAspectRatio <- 15
minWidth <- 8
minHeight <- 20
# tolerance <- 0.02
nTries <- 100
# Angles
if (is.null(angles)){
angles <- seq(-90, 90+angleStep, angleStep)*pi/180
}
else{ # Add all possible "square" orientations for each angle (e.g. 45, 135, -45, -135)
angles <- unlist(angles)
angles <- unique(c(angles,
angles + pi/2,
angles + pi,
angles - pi/2
))
angles <- angles %% (2*pi) %>% sort() %>% unique()
}
## print(angles)
##########################################
area <- st_area(polygon)
# Simple case: just one polygon, no hole, not closed
coord <- as_tibble(st_coordinates(polygon))
poly1 <- (coord %>% filter(L1 == 1) %>% select(X, Y))[-1,] %>% unlist() %>% unname() %>% matrix(ncol = 2)
poly2 <- NULL
if (mean(coord$L1) > 1){
poly2 <- (coord %>% filter(L1 == 2) %>% select(X, Y))[-1,] %>% unlist() %>% unname() %>% matrix(ncol = 2)
}
## print(poly1)
## print(poly2)
# get the width of the bounding box of the original polygon to determine tolerance
minx <- min(poly1[,1])
miny <- min(poly1[,2])
maxx <- max(poly1[,1])
maxy <- max(poly1[,2])
bBox <- rbind(c(minx, miny), c(maxx, miny), c(maxx, maxy), c(minx, maxy))
boxWidth <- maxx - minx
boxHeight <- maxy - miny
# discretize the binary search for optimal width to a resolution of this times the polygon width
widthStep <-  min(boxWidth, boxHeight)/100
# populate possible center points with random points inside the polygon
origins <- array(dim = c(0,2))
# get the centroid of the polygon
centroid <- st_coordinates(st_centroid(polygon)) %>% as.vector()
if (pointInPoly(centroid, poly1) && !pointInPoly(centroid, poly2)){
origins <- rbind(origins, centroid)
}
# get few more points inside the polygon
while (nrow(origins) < nTries){
rndX <- runif(1) * boxWidth + minx
rndY <- runif(1) * boxHeight + miny
rndPoint <- c(rndX, rndY)
if (pointInPoly(rndPoint, poly1) && !pointInPoly(rndPoint, poly2)){
origins <- rbind(origins, rndPoint)
}
}
## print(origins)
maxArea <- 0
maxRect <- NULL
rectOptions_i <- 1
iterMaxRect <- NULL
# Mother of for loops
for (i in 1:length(angles)){
## print(paste0("i =", i))
angleRad <- angles[i]
for (j in 1:nrow(origins)){
## print(paste0("j =", j))
origOrigin <- origins[j,]
origW <- intersectPoints(poly1, origOrigin, angleRad)
## print(paste0("origW =", origW))
origH <- intersectPoints(poly1, origOrigin, angleRad + pi/2)
## print(paste0("origH =", origH))
modifOrigins <- rbind(colMeans(origW), colMeans(origH)) # Two modified origins, using center of horizontal and verticle ray segments
## print(paste0("modifOrigins =", modifOrigins))
iterMaxArea <- 0
for (k in 1:nrow(modifOrigins)){
## print(paste0("k =", k))
origin <- modifOrigins[k,]
W <- intersectPoints(poly1, origin, angleRad)
## print(paste0("W =", W))
minSqDistW <- min(squaredDist(origin, W[1,]), squaredDist(origin, W[2,]))
maxWidth <- 2*sqrt(minSqDistW)
## print(paste0("maxWidth =", maxWidth))
H <- intersectPoints(poly1, origin, angleRad + pi/2)
## print(paste0("H =", H))
minSqDistH <- min(squaredDist(origin, H[1,]), squaredDist(origin, H[2,]))
maxHeight <- 2*sqrt(minSqDistH)
## print(paste0("maxHeight =", maxHeight))
minAspectRatio <- max(1, minWidth/maxHeight)
maxAspectRatio <- max(min(maxAspectRatio, maxWidth/minHeight),1)
if (minAspectRatio > maxAspectRatio){
aRatios <- minAspectRatio
}else{
aRatios <- seq(abs(minAspectRatio), abs(maxAspectRatio + aspectRatioStep), abs(aspectRatioStep))
}
## print(paste0("aRatios =", aRatios))
for (l in 1:length(aRatios)){
## print(paste0("l =", l))
aRatio <- aRatios[l]
# do a binary search to find the max width that works
left <- minWidth
right <- min(maxWidth, maxHeight*aRatio)
while ((right - left) >= widthStep){
width <- (left + right) / 2
height <- width / aRatio
x0 <- origin[1]
y0 <- origin[2]
rectPoly <- rbind(
c(x0 - width/2, y0 - height/2),
c(x0 + width/2, y0 - height/2),
c(x0 + width/2, y0 + height/2),
c(x0 - width/2, y0 + height/2)
)
## print(paste0("rectPoly =", rectPoly))
rectPoly <- rotatePoly(rectPoly, angleRad, origin)
## print(paste0("Rotated rectPoly =", rectPoly))
# (1) rectPoly does not intersect with both poly1 and poly2, (2) rectPoly is inside poly1, (3) rectPoly and poly2 are separate
if (!polyIntersect(rectPoly, poly1) && !polyIntersect(rectPoly, poly2) && polyInsidePoly(rectPoly, poly1) && !polyInsidePoly(rectPoly, poly2) && !polyInsidePoly(poly2, rectPoly)){
## print("rectPoly is inside poly")
insidePoly <- TRUE
if (width * height > iterMaxArea){
iterMaxArea <- width * height
rectPoly <- rbind(rectPoly, rectPoly[1,]) # close the polygon to export
iterMaxRect <- rectPoly
}
left <- width # increase the width in the binary search
# we know that the area is already greater than the maxArea found so far
if (width * height > maxArea){
## print("Max Area")
maxArea <- width * height
maxRect$cx <- x0
maxRect$cy <- y0
maxRect$width <- width
maxRect$height <- height
maxRect$angle
}
}
else{
insidePoly <- FALSE
right <- width
}
}
}
rectOptions[[rectOptions_i]] <- iterMaxRect
rectOptions_i <- rectOptions_i + 1
}
}
}
rectOptions <- compact(rectOptions)  # Remove null entries
## print(maxRect)
## print(maxArea)
## print(rectOptions)
return (list(maxRect, maxArea, rectOptions))
}
lr <- largestRect(st_geometry(result_Bldg0[i,]),result_Bldg0$slopes[i])
View(lr)
View(lr)
eqscplot(st_coordinates(result_Bldg0[i,])[,1:2], type='l')
for(x in 1:length(lr[[3]])){
lines(lr[[3]][[x]])
}
