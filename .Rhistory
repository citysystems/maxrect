Prop_Idle = N_Idle/5000,
Prop_Charge = Num_Charge/5000,
Prop_Drive = Num_Drive/5000
) %>%
rename(Charge = Prop_Charge, Drive = Prop_Drive, Idle = Prop_Idle) %>%
gather(key = State, value = prop, c(Charge, Drive, Idle))
df3 <-
df2 %>%
mutate(hour = hour(time), minute = minute(time)) %>%
mutate(time = make_datetime(min = minute, hour = hour))
glimpse(df3)
df4 <-
df3 %>%
select(time, `Trip ($)` = P_ride, `Electricity ($/kWh)` = P_elec) %>%
gather(key = Item, value = Price, c(`Trip ($)`, `Electricity ($/kWh)`))
df5 <-
df3 %>%
mutate(`Must Charge` = `Must_Charge` / 5000, `Fleet SOC` = U_ev_prop) %>%
select(time, `Must Charge`, `Fleet SOC`) %>%
gather(key = Type, value = Proportion, -time)
df6 <-
df3 %>%
select(time, Supply = S_max, Demand = D_max) %>%
gather(key = ` `, value = `#`, -time)
df3 %>%
ggplot(aes(x = time, y = prop)) +
geom_line(aes(color = State)) +
labs(
title = "Breakdown of EV Fleet State",
x = "Time",
y = "Proportion"
) +
scale_x_datetime(date_breaks = "2 hours", date_labels = "%H:%M") +
theme_bw()
df4 %>%
ggplot(aes(x = time, y = Price)) +
geom_line(aes(color = Item)) +
labs(
title = "EV Fleet Dynamic Pricing",
x = "Time",
y = "Cost"
) +
scale_x_datetime(date_breaks = "2 hours", date_labels = "%H:%M") +
theme_bw()
df5 %>%
ggplot(aes(x = time, y = Proportion)) +
geom_line(aes(color = Type)) +
labs(
title = "EV Fleet Charge Status",
x = "Time",
y = "Proportion"
) +
scale_x_datetime(date_breaks = "2 hours", date_labels = "%H:%M") +
theme_bw()
df6 %>%
ggplot(aes(x = time, y = `#`)) +
geom_line(aes(color = ` `)) +
labs(
title = "Supply-Demand",
x = "Time",
y = "Maximum Quantity"
) +
scale_x_datetime(date_breaks = "2 hours", date_labels = "%H:%M") +
theme_bw()
df2 <-
df %>%
mutate(
Prop_Idle = N_Idle/5000,
Prop_Charge = Num_Charge/5000,
Prop_Drive = Num_Drive/5000,
P_elec = P_elec * 1000
) %>%
rename(Charge = Prop_Charge, Drive = Prop_Drive, Idle = Prop_Idle) %>%
gather(key = State, value = prop, c(Charge, Drive, Idle))
df3 <-
df2 %>%
mutate(hour = hour(time), minute = minute(time)) %>%
mutate(time = make_datetime(min = minute, hour = hour))
df4 <-
df3 %>%
select(time, `Trip ($)` = P_ride, `Electricity ($/kWh)` = P_elec) %>%
gather(key = Item, value = Price, c(`Trip ($)`, `Electricity ($/kWh)`))
df5 <-
df3 %>%
mutate(`Must Charge` = `Must_Charge` / 5000, `Fleet SOC` = U_ev_prop) %>%
select(time, `Must Charge`, `Fleet SOC`) %>%
gather(key = Type, value = Proportion, -time)
df6 <-
df3 %>%
select(time, Supply = S_max, Demand = D_max) %>%
gather(key = ` `, value = `#`, -time)
df4 <-
df3 %>%
select(time, `Trip ($)` = P_ride, `Electricity ($/MWh)` = P_elec) %>%
gather(key = Item, value = Price, c(`Trip ($)`, `Electricity ($/MWh)`))
df5 <-
df3 %>%
mutate(`Must Charge` = `Must_Charge` / 5000, `Fleet SOC` = U_ev_prop) %>%
select(time, `Must Charge`, `Fleet SOC`) %>%
gather(key = Type, value = Proportion, -time)
df6 <-
df3 %>%
select(time, Supply = S_max, Demand = D_max) %>%
gather(key = ` `, value = `#`, -time)
df3 %>%
ggplot(aes(x = time, y = prop)) +
geom_line(aes(color = State)) +
labs(
title = "Breakdown of EV Fleet State",
x = "Time",
y = "Proportion"
) +
scale_x_datetime(date_breaks = "2 hours", date_labels = "%H:%M") +
theme_bw()
df4 %>%
ggplot(aes(x = time, y = Price)) +
geom_line(aes(color = Item)) +
labs(
title = "EV Fleet Dynamic Pricing",
x = "Time",
y = "Cost"
) +
scale_x_datetime(date_breaks = "2 hours", date_labels = "%H:%M") +
theme_bw()
df5 %>%
ggplot(aes(x = time, y = Proportion)) +
geom_line(aes(color = Type)) +
labs(
title = "EV Fleet Charge Status",
x = "Time",
y = "Proportion"
) +
scale_x_datetime(date_breaks = "2 hours", date_labels = "%H:%M") +
theme_bw()
df6 %>%
ggplot(aes(x = time, y = `#`)) +
geom_line(aes(color = ` `)) +
labs(
title = "Supply-Demand",
x = "Time",
y = "Maximum Quantity"
) +
scale_x_datetime(date_breaks = "2 hours", date_labels = "%H:%M") +
theme_bw()
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(readr)
library(stringr)
head(indiv)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(readr)
library(stringr)
file_base <- "~/224Z/"
indiv_file <- str_c(file_base, "indivTripData_3.csv")
joint_file <- str_c(file_base, "jointTripData_3.csv")
indiv <- read_csv(indiv_file)
save.image("~/224Z/tripaggr.RData")
indiv_mod <-
indiv %>%
filter(orig_taz != dest_taz)
indiv_aggr <-
indiv_mod %>%
group_by(orig_taz, dest_taz) %>%
summarise(n = n())
indiv_aggr_mode <-
indiv_mod %>%
filter(trip_mode <= 6) %>%
group_by(orig_taz, dest_taz, trip_mode) %>%
summarise(n = n())
indiv_aggr_mode %>%
group_by(trip_mode) %>%
summarise(n = n())
head(indiv)
indiv_aggr_mode
indiv_aggr_mode %>%
group_by(trip_mode) %>%
summarise(n = n()) %>%
mutate(
ifelse(
trip_mode <= 2,
count = n,
ifelse(
trip_mode <= 4,
count = n/2,
count = n/3
)
)
)
indiv_aggr_mode %>%
group_by(trip_mode) %>%
summarise(n = n()) %>%
mutate(
count =
ifelse(
trip_mode <= 2,
n,
ifelse(trip_mode <= 4,
n / 2,
n / 3)
)
)
indiv_aggr_mode %>%
group_by(trip_mode) %>%
summarise(n = n()) %>%
ungroup() %>%
mutate(
count =
ifelse(
trip_mode <= 2,
n,
ifelse(trip_mode <= 4,
n / 2,
n / 3)
)
)
indiv_aggr_mode %>%
group_by(trip_mode) %>%
summarise(n = n())
indiv_aggr_mode
indiv_aggr_mode %>%
mutate(
count =
ifelse(
trip_mode <= 2,
n,
ifelse(trip_mode <= 4,
n / 2,
n / 3)
)
)
?gather()
?slice()
indiv_test %>%
slice(5)
indiv_aggr_mode %>%
slice(5)
indiv_aggr_mode %>%
head(n = 5)
indiv_aggr_mode %>%
head(n = 5) %>%
group_by(orig_taz, dest_taz) %>%
summarize(count = sum(n))
indiv_aggr_car <-
indiv_aggr_mode %>%
mutate(
count =
ifelse(
trip_mode <= 2,
n,
ifelse(trip_mode <= 4,
n / 2,
n / 3)
)
) %>%
group_by(orig_taz, dest_taz) %>%
summarize(car_count = sum(n))
x <- seq(2010, 2016, 1)
x <- seq(2010, 2016, 1)
x
library(tidyverse)
a <- seq(2010,2016,1)
b <- c(0.724, 0.717, 0.714, 0.707, 0.702, 0.699, 0.69)
trend.line(a,b)
mydf <- data.frame(x = a, y = b)
model <- lm(y ~ x, data = mydf)
plot(y ~ x, data = mydf)
model <- lm(y ~ x, data = mydf)
abline(model, col = "red")
summary(model)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(readr)
library(stringr)
knitr::opts_chunk$set(echo = TRUE)
file_base <- "~/224Z/"
indiv_file <- str_c(file_base, "indivTripData_3.csv")
joint_file <- str_c(file_base, "jointTripData_3.csv")
joint <- read_csv(joint_file)
indiv <- read_csv(indiv_file)
install.packages()
help(install.packages())
install.packages("tidyverse", dependencies = TRUE)
setwd("~/GitHub/maxrect")
load("~/GitHub/maxrect/.RData")
x_merge <- c(6088888.3320386177,6088887.5778603116,6088924.7236851258,6088925.4778041998,6088888.3320386177,
6088869.3009999944,6088969.2960000103,6088969.3339999998,6088969.5630000085,6088869.5660000127,6088869.3009999944,
6088888.3320386177)
y_merge <- c(1994297.0048188232,1994253.6826348184,1994253.0360036378,1994296.3581886755,1994297.0048188232,
1994300.7799999823,1994302.0189999985,1994294.6689999939,1994249.6080000065,1994248.8560000029,1994300.7799999823,
1994297.0048188232)
xy_merge <- cbind(x_merge,y_merge)
xy_merge
View(xy_merge)
library("dplyr")
?mutate_all()
?round()
xy_merge2 %>% mutate_all(round(4))
x_merge2 <- all_merged_rings[[359]][[3]][,1]
y_merge2 <- all_merged_rings[[359]][[3]][,2]
xy_merge2 <- cbind(x_merge2, y_merge2)
xy_merge2 %>% mutate_all(round(4))
mutate_all(xy_merge2, round(4))
sapply(xy_merge2, round(4))
sapply(xy_merge2, function(x) round(x, 4))
test <- sapply(xy_merge2, function(x) round(x, 4))
test <- sapply(xy_merge2, function(x) round(x, 4))
lr = find_lr(ctx, test)
initjs <- function(){
### initialise a v8 context and load d3, simplify, and the largest rectangle
### scripts
ct = v8()
ct$eval("window={}")
ct$source("http://d3js.org/d3.v3.min.js")
ct$source("http://d3plus.org/assets/posts/largestRect/lib/simplify.js")
### simplify loads into the window context but the largestRect needs it in main:
ct$eval("simplify = window.simplify")
### transpile to JS and evaluate
lr = coffee_compile(readLines("largestRect.coffee"))
ct$eval(lr)
### return the context
ct
}
plotrect <- function(lr1){
## convert rectangle output to coordinates
## zero-centred
pts = cbind(
c(lr1$width,lr1$width,-lr1$width,-lr1$width)/2,
c(lr1$height,-lr1$height,-lr1$height,lr1$height)/2
)
## rotate
r = rmat(lr1$ang)
xy = pts %*% r
## add centre offsets
xy[,1] = xy[,1] + lr1$cx
xy[,2] = xy[,2] + lr1$cy
## repeat last point so output is a closed polygon
rbind(xy,xy[1,])
}
plotrect <- function(lr1){
## convert rectangle output to coordinates
## zero-centred
pts = cbind(
c(lr1$width,lr1$width,-lr1$width,-lr1$width)/2,
c(lr1$height,-lr1$height,-lr1$height,lr1$height)/2
)
## rotate
r = rmat(lr1$ang)
xy = pts %*% r
## add centre offsets
xy[,1] = xy[,1] + lr1$cx
xy[,2] = xy[,2] + lr1$cy
## repeat last point so output is a closed polygon
rbind(xy,xy[1,])
}
ctx = initjs()
library(maxrectangle)
library(readr)
library(MASS)
library("jsonlite")
library("dplyr")
ctx = initjs()
ctx = initjs()
initjs <- function(){
### initialise a v8 context and load d3, simplify, and the largest rectangle
### scripts
ct = v8()
ct$eval("window={}")
ct$source("http://d3js.org/d3.v3.min.js")
ct$source("http://d3plus.org/assets/posts/largestRect/lib/simplify.js")
### simplify loads into the window context but the largestRect needs it in main:
ct$eval("simplify = window.simplify")
### transpile to JS and evaluate
lr = coffee_compile(readLines("largestRect.coffee"))
ct$eval(lr)
### return the context
ct
}
rmat <- function(ang){
## rotation matrix
ang = ang*pi/180
sa = sin(ang)
ca = cos(ang)
rbind(c(ca,-sa),c(sa,ca))
}
##' Init a JS context
##'
##' Init a JS context
##' @title Init a JS context
##' @return a V8 context
##' @author Barry Rowlingson
##' @export
initjs <- function(){
### initialise a v8 context and load d3, simplify, and the largest rectangle
### scripts
ct = v8()
ct$eval("window={}")
ct$source("http://d3js.org/d3.v3.min.js")
ct$source("http://d3plus.org/assets/posts/largestRect/lib/simplify.js")
### simplify loads into the window context but the largestRect needs it in main:
ct$eval("simplify = window.simplify")
### transpile to JS and evaluate
lr = coffee_compile(readLines("largestRect.coffee"))
ct$eval(lr)
### return the context
ct
}
##' Return the largest fitting rectangle
##'
##' Return the largest fitting rectangle
##' @title Largest Fitting Rectangle
##' @param ct a V8 context
##' @param xy a two-column matrix
##' @param options list of options
##' @return rectangle structure
##' @author Barry Rowlingson
##' @examples
##' \dontrun {
##' ctx = initjs()
##' th = seq(0,2*pi,len=11)[-11]
##' r = runif(10)
##' xy = cbind(r*cos(th), r*sin(th))
##' xy = rbind(xy, xy[1,])
##' plot(xy, type="l",asp=1)
##' lr = find_lr(ctx, xy)
##' pp = plotrect(lr[[1]])
##' lines(pp)
##' }
##' @export
##'
find_lr <- function(ct, xy, options){
## xy MUST be a two-column matrix. This transfers it as
## an Array of Arrays:
ct$assign("xy",xy)
## call the largest rectangle routine and return the result
## TODO: pass options here
tryCatch({
lrect = ct$get("window.largestRect(xy)")
lrect
}, error = function(e){
print("error")
find_lr(ct, xy)
}
)
# lrect
}
##' Rotation matrix
##'
##' Rotation Matrix
##' @title Rotation Matrix
##' @param ang rotation angle
##' @return a 2d rotation matrix
##' @author Barry Rowlingson
##' @export
rmat <- function(ang){
## rotation matrix
ang = ang*pi/180
sa = sin(ang)
ca = cos(ang)
rbind(c(ca,-sa),c(sa,ca))
}
##' Convert rectangle structure to coordinates for plotting
##'
##' Convert rectangle structure to coordinates for plotting
##' @title .. content for \details{} ..
##' @param lr1 a rectangle structure
##' @return a two-column matrix
##' @author Barry Rowlingson
plotrect <- function(lr1){
## convert rectangle output to coordinates
## zero-centred
pts = cbind(
c(lr1$width,lr1$width,-lr1$width,-lr1$width)/2,
c(lr1$height,-lr1$height,-lr1$height,lr1$height)/2
)
## rotate
r = rmat(lr1$ang)
xy = pts %*% r
## add centre offsets
xy[,1] = xy[,1] + lr1$cx
xy[,2] = xy[,2] + lr1$cy
## repeat last point so output is a closed polygon
rbind(xy,xy[1,])
}
###
### example
###
# ct = initjs()
# # then repeat:
#   xy = rbind(c(0,0),c(1,0),c(0.5,1),c(0,0))
#   lr = find_lr(ct, xy)
#   pp = plotrect(lr[[1]])
#   plot(xy, type="l",asp=1)
#   lines(pp)
# # (the context `ct` can be reused)
plotrect <- function(lr1){
## convert rectangle output to coordinates
## zero-centred
pts = cbind(
c(lr1$width,lr1$width,-lr1$width,-lr1$width)/2,
c(lr1$height,-lr1$height,-lr1$height,lr1$height)/2
)
## rotate
r = rmat(lr1$ang)
xy = pts %*% r
## add centre offsets
xy[,1] = xy[,1] + lr1$cx
xy[,2] = xy[,2] + lr1$cy
## repeat last point so output is a closed polygon
rbind(xy,xy[1,])
}
ctx = initjs()
