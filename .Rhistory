test
for (i in 3869:numPar){
if (!misfits[i]){
print(i)
par <- parcel[[i]][,1:2]
edges <- parcelEdges[[i]]
bldg <- st_coordinates(bldg_all[i,])[,1:2]
front <- parcelFront(i, "Mod")
side_dist <- 5
rear_dist <- 10
geom <- allBuffers(par, edges, bldg, front, side_dist, rear_dist, bldg_dist = 0)
if (is.character(geom) || nrow(geom) == 0){
sf <- st_sf(APN = parcels$properties.APN[[i]], geometry = st_sfc(st_polygon()))
}
else{
sf <- st_sf(data.frame(tibble(APN = parcels$properties.APN[[i]]),geom))
}
result_Bldg0 <- rbind(result_Bldg0, sf)
}
}
misfits[3868]
# Side and rear buffers
# Input: parcel, edgeID (front, side, rear), building footprint, front points
# Param: side buffer dist, rear buffer dist
# Draw parallel lines that are [buffer dist] away from each side
# Select parallel lines that are closer to parcel centroid, so lines are going inward, not outward
# Find intersection between adjacent lines to reconstruct buffered parcel
# Check whether buffer overlaps with building. If it does, adjust so that there is no intersection in result
# Output: new parcel coordinates, array (n by 2)
allBuffers <- function(par, edges, bldg, front, side_dist, rear_dist, bldg_dist = 0){
buffers <- array(dim = c(0, 4))
skipFront <- FALSE               # Keep track of whether front cut was already added. If so, skip other front edges
# Find the lines for all the buffers
for (i in 1:length(edges)){
if (edges[i] == "Front"){
if (skipFront){
next
}
else{
buffers <- rbind(buffers, removeFront(par, bldg, front)[1:2])
skipFront <- TRUE
}
}
else if (edges[i] == "Side"){
buffers <- rbind(buffers, buffer(par, i, side_dist))
}
else if (edges[i] == "Rear"){
buffers <- rbind(buffers, buffer(par, i, rear_dist))
}
}
buffers <- rbind(buffers, buffers[1,])      # Wrap around for easier looping later
# print(buffers)
newPar <- array(dim = c(nrow(buffers), 2))
for (i in 1:(nrow(buffers)-1)){
# print(paste("Buffer", i))
newPar[i,] <- intersectLines(buffers[i,],buffers[i+1,])
}
newPar[nrow(buffers),] <- newPar[1,]
# print(newPar)
# Check if new parcel has any intersections due to buffers overtaking edge(s)
# Use st_is_valid() to check
sf_newPar <- st_as_sf(SpatialPolygons(list(Polygons(list(Polygon(newPar)),1))))
# print("test2")
# Remove building parcel from new parcel
sf_bldg <- st_as_sf(SpatialPolygons(list(Polygons(list(Polygon(bldg)),1))))
sf_bldg <- st_buffer(sf_bldg, bldg_dist)
# print("test3")
# If there are intersections, this will split into multiple polygons. If not, nothing changes
split <- st_cast(st_make_valid(sf_newPar), "POLYGON")
split <- st_difference(split, sf_bldg)
split <- st_cast(split, "POLYGON")
# return(split)
if (nrow(split) == 0){
return ("No suitable polygons")
}
# Get the order of polygons by largest to smallest
# ord <- order(st_area(split), decreasing = TRUE)
split <- cbind(valid = vector("logical", length = nrow(split)), split)
for (i in 1:nrow(split)){
# inverted <- FALSE     # Track
# poly <- split[ord[i],]
# If polygon is not inverted, mark as valid
# Check shortest distance between polygon centroid and each edge.
cent <- st_coordinates(st_centroid(split[i,]))
split$valid[i] <- TRUE
for (j in 1:length(edges)){
if (edges[j] == "Front") {next} # Skip front facing, since we don't know the distance
else if (edges[j] == "Side") {dist <- side_dist}
else {dist <- rear_dist}
# distPtLineSeg <- function(x, y, x1, y1, x2, y2){
# If the distance > respective buffer, not inverted. Skip to next polygon
if (dist > distPtLineSeg(cent[1], cent[2], par[j,1], par[j,2], par[j+1,1], par[j+1,2])){
split$valid[i] <- FALSE
break
}
}
# # If after checking all the sides, not marked as inverted, add this polygon
# if (!inverted){
#   # polys <- rbind(polys, poly)
#   return(poly)
# }
}
if (sum(split$check) == 0){
print(split)
return ("No suitable polygons")
}
else{
print(split)
return (split)
}
#
# if (length(polys) > 0){
#
# }
# else{
# return ("No suitable polygons")
# }
}
# Find the available area after buffers. No building set back. Side = 5 ft, Rear = 10 ft
result_Bldg0 <- NULL
misfits[905] <- TRUE
misfits[3458] <- TRUE
misfits[3480] <- TRUE
misfits[3539] <- TRUE
misfits[3612] <- TRUE
misfits[3869] <- TRUE
for (i in 3869:numPar){
if (!misfits[i]){
print(i)
par <- parcel[[i]][,1:2]
edges <- parcelEdges[[i]]
bldg <- st_coordinates(bldg_all[i,])[,1:2]
front <- parcelFront(i, "Mod")
side_dist <- 5
rear_dist <- 10
geom <- allBuffers(par, edges, bldg, front, side_dist, rear_dist, bldg_dist = 0)
if (is.character(geom) || nrow(geom) == 0){
sf <- st_sf(APN = parcels$properties.APN[[i]], geometry = st_sfc(st_polygon()))
}
else{
sf <- st_sf(data.frame(tibble(APN = parcels$properties.APN[[i]]),geom))
}
result_Bldg0 <- rbind(result_Bldg0, sf)
}
}
# Find the available area after buffers. No building set back. Side = 5 ft, Rear = 10 ft
result_Bldg0 <- NULL
for (i in 1:numPar){
if (!misfits[i]){
print(i)
par <- parcel[[i]][,1:2]
edges <- parcelEdges[[i]]
bldg <- st_coordinates(bldg_all[i,])[,1:2]
front <- parcelFront(i, "Mod")
side_dist <- 5
rear_dist <- 10
geom <- allBuffers(par, edges, bldg, front, side_dist, rear_dist, bldg_dist = 0)
if (is.character(geom) || nrow(geom) == 0){
sf <- st_sf(APN = parcels$properties.APN[[i]], geometry = st_sfc(st_polygon()))
}
else{
sf <- st_sf(data.frame(tibble(APN = parcels$properties.APN[[i]]),geom))
}
result_Bldg0 <- rbind(result_Bldg0, sf)
}
}
View(result_Bldg0)
View(result_Bldg0)
# Side and rear buffers
# Input: parcel, edgeID (front, side, rear), building footprint, front points
# Param: side buffer dist, rear buffer dist
# Draw parallel lines that are [buffer dist] away from each side
# Select parallel lines that are closer to parcel centroid, so lines are going inward, not outward
# Find intersection between adjacent lines to reconstruct buffered parcel
# Check whether buffer overlaps with building. If it does, adjust so that there is no intersection in result
# Output: new parcel coordinates, array (n by 2)
allBuffers <- function(par, edges, bldg, front, side_dist, rear_dist, bldg_dist = 0){
buffers <- array(dim = c(0, 4))
skipFront <- FALSE               # Keep track of whether front cut was already added. If so, skip other front edges
# Find the lines for all the buffers
for (i in 1:length(edges)){
if (edges[i] == "Front"){
if (skipFront){
next
}
else{
buffers <- rbind(buffers, removeFront(par, bldg, front)[1:2])
skipFront <- TRUE
}
}
else if (edges[i] == "Side"){
buffers <- rbind(buffers, buffer(par, i, side_dist))
}
else if (edges[i] == "Rear"){
buffers <- rbind(buffers, buffer(par, i, rear_dist))
}
}
buffers <- rbind(buffers, buffers[1,])      # Wrap around for easier looping later
# print(buffers)
newPar <- array(dim = c(nrow(buffers), 2))
for (i in 1:(nrow(buffers)-1)){
# print(paste("Buffer", i))
newPar[i,] <- intersectLines(buffers[i,],buffers[i+1,])
}
newPar[nrow(buffers),] <- newPar[1,]
# print(newPar)
# Check if new parcel has any intersections due to buffers overtaking edge(s)
# Use st_is_valid() to check
sf_newPar <- st_as_sf(SpatialPolygons(list(Polygons(list(Polygon(newPar)),1))))
# print("test2")
# Remove building parcel from new parcel
sf_bldg <- st_as_sf(SpatialPolygons(list(Polygons(list(Polygon(bldg)),1))))
sf_bldg <- st_buffer(sf_bldg, bldg_dist)
# print("test3")
# If there are intersections, this will split into multiple polygons. If not, nothing changes
split <- st_cast(st_make_valid(sf_newPar), "POLYGON")
split <- st_difference(split, sf_bldg)
split <- st_cast(split, "POLYGON")
# return(split)
if (nrow(split) == 0){
return ("No suitable polygons")
}
# Get the order of polygons by largest to smallest
# ord <- order(st_area(split), decreasing = TRUE)
split <- cbind(valid = vector("logical", length = nrow(split)), split)
for (i in 1:nrow(split)){
# inverted <- FALSE     # Track
# poly <- split[ord[i],]
# If polygon is not inverted, mark as valid
# Check shortest distance between polygon centroid and each edge.
cent <- st_coordinates(st_centroid(split[i,]))
split$valid[i] <- TRUE
for (j in 1:length(edges)){
if (edges[j] == "Front") {next} # Skip front facing, since we don't know the distance
else if (edges[j] == "Side") {dist <- side_dist}
else {dist <- rear_dist}
# distPtLineSeg <- function(x, y, x1, y1, x2, y2){
# If the distance > respective buffer, not inverted. Skip to next polygon
if (dist > distPtLineSeg(cent[1], cent[2], par[j,1], par[j,2], par[j+1,1], par[j+1,2])){
split$valid[i] <- FALSE
break
}
}
# # If after checking all the sides, not marked as inverted, add this polygon
# if (!inverted){
#   # polys <- rbind(polys, poly)
#   return(poly)
# }
}
if (sum(split$valid) == 0){
# print(split)
return ("No suitable polygons")
}
else{
# print(split)
return(split)
}
#
# if (length(polys) > 0){
#
# }
# else{
# return ("No suitable polygons")
# }
}
# Find the available area after buffers. No building set back. Side = 5 ft, Rear = 10 ft
result_Bldg0 <- NULL
for (i in 1:numPar){
if (!misfits[i]){
print(i)
par <- parcel[[i]][,1:2]
edges <- parcelEdges[[i]]
bldg <- st_coordinates(bldg_all[i,])[,1:2]
front <- parcelFront(i, "Mod")
side_dist <- 5
rear_dist <- 10
geom <- allBuffers(par, edges, bldg, front, side_dist, rear_dist, bldg_dist = 0)
if (is.character(geom) || nrow(geom) == 0){
sf <- st_sf(APN = parcels$properties.APN[[i]], geometry = st_sfc(st_polygon()))
}
else{
sf <- st_sf(data.frame(tibble(APN = parcels$properties.APN[[i]]),geom))
}
result_Bldg0 <- rbind(result_Bldg0, sf)
}
}
geom
is.character(geom)
st_sf(APN = parcels$properties.APN[[230]], geometry = st_sfc(st_polygon()))
View(result_Bldg0)
# Side and rear buffers
# Input: parcel, edgeID (front, side, rear), building footprint, front points
# Param: side buffer dist, rear buffer dist
# Draw parallel lines that are [buffer dist] away from each side
# Select parallel lines that are closer to parcel centroid, so lines are going inward, not outward
# Find intersection between adjacent lines to reconstruct buffered parcel
# Check whether buffer overlaps with building. If it does, adjust so that there is no intersection in result
# Output: new parcel coordinates, array (n by 2)
allBuffers <- function(par, edges, bldg, front, side_dist, rear_dist, bldg_dist = 0){
buffers <- array(dim = c(0, 4))
skipFront <- FALSE               # Keep track of whether front cut was already added. If so, skip other front edges
# Find the lines for all the buffers
for (i in 1:length(edges)){
if (edges[i] == "Front"){
if (skipFront){
next
}
else{
buffers <- rbind(buffers, removeFront(par, bldg, front)[1:2])
skipFront <- TRUE
}
}
else if (edges[i] == "Side"){
buffers <- rbind(buffers, buffer(par, i, side_dist))
}
else if (edges[i] == "Rear"){
buffers <- rbind(buffers, buffer(par, i, rear_dist))
}
}
buffers <- rbind(buffers, buffers[1,])      # Wrap around for easier looping later
# print(buffers)
newPar <- array(dim = c(nrow(buffers), 2))
for (i in 1:(nrow(buffers)-1)){
# print(paste("Buffer", i))
newPar[i,] <- intersectLines(buffers[i,],buffers[i+1,])
}
newPar[nrow(buffers),] <- newPar[1,]
# print(newPar)
# Check if new parcel has any intersections due to buffers overtaking edge(s)
# Use st_is_valid() to check
sf_newPar <- st_as_sf(SpatialPolygons(list(Polygons(list(Polygon(newPar)),1))))
# print("test2")
# Remove building parcel from new parcel
sf_bldg <- st_as_sf(SpatialPolygons(list(Polygons(list(Polygon(bldg)),1))))
sf_bldg <- st_buffer(sf_bldg, bldg_dist)
# print("test3")
# If there are intersections, this will split into multiple polygons. If not, nothing changes
split <- st_cast(st_make_valid(sf_newPar), "POLYGON")
split <- st_difference(split, sf_bldg)
split <- st_cast(split, "POLYGON")
# return(split)
if (nrow(split) == 0){
return ("No suitable polygons")
}
# Get the order of polygons by largest to smallest
# ord <- order(st_area(split), decreasing = TRUE)
split <- cbind(valid = vector("logical", length = nrow(split)), split)
for (i in 1:nrow(split)){
# inverted <- FALSE     # Track
# poly <- split[ord[i],]
# If polygon is not inverted, mark as valid
# Check shortest distance between polygon centroid and each edge.
cent <- st_coordinates(st_centroid(split[i,]))
split$valid[i] <- TRUE
for (j in 1:length(edges)){
if (edges[j] == "Front") {next} # Skip front facing, since we don't know the distance
else if (edges[j] == "Side") {dist <- side_dist}
else {dist <- rear_dist}
# distPtLineSeg <- function(x, y, x1, y1, x2, y2){
# If the distance > respective buffer, not inverted. Skip to next polygon
if (dist > distPtLineSeg(cent[1], cent[2], par[j,1], par[j,2], par[j+1,1], par[j+1,2])){
split$valid[i] <- FALSE
break
}
}
# # If after checking all the sides, not marked as inverted, add this polygon
# if (!inverted){
#   # polys <- rbind(polys, poly)
#   return(poly)
# }
}
if (sum(split$valid) == 0){
# print(split)
return ("No suitable polygons")
}
else{
# print(split)
return(split %>% select(APN))
}
#
# if (length(polys) > 0){
#
# }
# else{
# return ("No suitable polygons")
# }
}
# Side and rear buffers
# Input: parcel, edgeID (front, side, rear), building footprint, front points
# Param: side buffer dist, rear buffer dist
# Draw parallel lines that are [buffer dist] away from each side
# Select parallel lines that are closer to parcel centroid, so lines are going inward, not outward
# Find intersection between adjacent lines to reconstruct buffered parcel
# Check whether buffer overlaps with building. If it does, adjust so that there is no intersection in result
# Output: new parcel coordinates, array (n by 2)
allBuffers <- function(par, edges, bldg, front, side_dist, rear_dist, bldg_dist = 0){
buffers <- array(dim = c(0, 4))
skipFront <- FALSE               # Keep track of whether front cut was already added. If so, skip other front edges
# Find the lines for all the buffers
for (i in 1:length(edges)){
if (edges[i] == "Front"){
if (skipFront){
next
}
else{
buffers <- rbind(buffers, removeFront(par, bldg, front)[1:2])
skipFront <- TRUE
}
}
else if (edges[i] == "Side"){
buffers <- rbind(buffers, buffer(par, i, side_dist))
}
else if (edges[i] == "Rear"){
buffers <- rbind(buffers, buffer(par, i, rear_dist))
}
}
buffers <- rbind(buffers, buffers[1,])      # Wrap around for easier looping later
# print(buffers)
newPar <- array(dim = c(nrow(buffers), 2))
for (i in 1:(nrow(buffers)-1)){
# print(paste("Buffer", i))
newPar[i,] <- intersectLines(buffers[i,],buffers[i+1,])
}
newPar[nrow(buffers),] <- newPar[1,]
# print(newPar)
# Check if new parcel has any intersections due to buffers overtaking edge(s)
# Use st_is_valid() to check
sf_newPar <- st_as_sf(SpatialPolygons(list(Polygons(list(Polygon(newPar)),1))))
# print("test2")
# Remove building parcel from new parcel
sf_bldg <- st_as_sf(SpatialPolygons(list(Polygons(list(Polygon(bldg)),1))))
sf_bldg <- st_buffer(sf_bldg, bldg_dist)
# print("test3")
# If there are intersections, this will split into multiple polygons. If not, nothing changes
split <- st_cast(st_make_valid(sf_newPar), "POLYGON")
split <- st_difference(split, sf_bldg)
split <- st_cast(split, "POLYGON")
# return(split)
if (nrow(split) == 0){
return ("No suitable polygons")
}
# Get the order of polygons by largest to smallest
# ord <- order(st_area(split), decreasing = TRUE)
split <- cbind(valid = vector("logical", length = nrow(split)), split)
for (i in 1:nrow(split)){
# inverted <- FALSE     # Track
# poly <- split[ord[i],]
# If polygon is not inverted, mark as valid
# Check shortest distance between polygon centroid and each edge.
cent <- st_coordinates(st_centroid(split[i,]))
split$valid[i] <- TRUE
for (j in 1:length(edges)){
if (edges[j] == "Front") {next} # Skip front facing, since we don't know the distance
else if (edges[j] == "Side") {dist <- side_dist}
else {dist <- rear_dist}
# distPtLineSeg <- function(x, y, x1, y1, x2, y2){
# If the distance > respective buffer, not inverted. Skip to next polygon
if (dist > distPtLineSeg(cent[1], cent[2], par[j,1], par[j,2], par[j+1,1], par[j+1,2])){
split$valid[i] <- FALSE
break
}
}
# # If after checking all the sides, not marked as inverted, add this polygon
# if (!inverted){
#   # polys <- rbind(polys, poly)
#   return(poly)
# }
}
if (sum(split$valid) == 0){
# print(split)
return ("No suitable polygons")
}
else{
# print(split)
return(split)
}
#
# if (length(polys) > 0){
#
# }
# else{
# return ("No suitable polygons")
# }
}
?st_sf()
st_sf(APN = parcels$properties.APN[[230]], valid = FALSE, geometry = st_sfc(st_polygon()))
# Find the available area after buffers. No building set back. Side = 5 ft, Rear = 10 ft
result_Bldg0 <- NULL
for (i in 1:numPar){
if (!misfits[i]){
print(i)
par <- parcel[[i]][,1:2]
edges <- parcelEdges[[i]]
bldg <- st_coordinates(bldg_all[i,])[,1:2]
front <- parcelFront(i, "Mod")
side_dist <- 5
rear_dist <- 10
geom <- allBuffers(par, edges, bldg, front, side_dist, rear_dist, bldg_dist = 0)
if (is.character(geom) || nrow(geom) == 0){
sf <- st_sf(APN = parcels$properties.APN[[i]], valid = FALSE, geometry = st_sfc(st_polygon()))
}
else{
sf <- st_sf(data.frame(tibble(APN = parcels$properties.APN[[i]]),geom))
}
result_Bldg0 <- rbind(result_Bldg0, sf)
}
}
View(result_Bldg0)
plot(result_Bldg0[1,])
plot(result_Bldg0[1,1])
plot(result_Bldg0[3868,1])
save.image(".RData")
