opt1[index,] <- parcelPoints[1,]  # back to point A
opt1 <- opt1[which(rowSums(opt1)>0),]
# Option 2: loop from higher index (B) back to lower index (A)
opt2[1,] <- parcelPoints[2,] # point B
index <- 2
i <- B + 1
if (i > dim(par)[1]){   # If B is the last index, adjust i to 1
i <- 1
}
while (i != A){
opt2[index,] <- par[i,]
i <- i + 1
if (i > dim(par)[1]){
i <- 1
}
}
opt2[index,] <- parcelPoints[1,] # point A
index <- index + 1
opt2[index,] <- parcelPoints[2,] # point B
opt2 <- opt2[which(rowSums(opt2)>0),]
# Check if option 1 goes through front
for (i in 1:dim(opt1)[1]){
# if (isFront1(opt1[i,])){
#   return (opt2)
# }
for (j in 1:dim(front)[1]){
if (opt1[i,] == front[j,]){  # If any point is on the front, return option 2
return (opt2)
}
}
}
return (opt1)
}
# Other cases: deal with later
else {print("Abnormal number of intersections")}
}
test <- removeFront(test_par, test_bldg, test_front)
# Cut out front yard
# Input: parcel_data, building_data, parcelFront
# Use first and last front edge points to draw a line
# Find point or edge on building that is closest (perpendicular distance)
# Find line equation for front edge of building, then find intersection points on parcel
# Output: new parcel coordinates, array (n by 2)
removeFront <- function(par, bldg, front){
p_i <- front[1,]
p_f <- front[dim(front)[1],]
minIndex <- 0   # track index for closest point to line
minDist <- 1e99 # track associated minimum distance
for (i in 1:dim(bldg)[1]){
dist <- perpDist(bldg[i,1], bldg[i,2], p_i[1], p_i[2], p_f[1], p_f[2])
if (dist < minDist){
minIndex <- i
minDist <- dist
}
}
print(minIndex)
print(minDist)
# Find parallel line
ang <- atan2((p_f-p_i)[2],(p_f-p_i)[1])/pi*180
pt <- bldg[minIndex,]
print(ang)
print(pt)
# For each line of the parcel, check if intersects with front cut line
# Store (1) index of parcel side and (2) intersection point on parcel
# Usually will be two intersections, but may be more if unusual shape
parcelIndex <- vector("double")
parcelPoints <- array(dim = c(0,2))
for (i in 1:(dim(par)[1]-1)){
p1 <- par[i,]
p2 <- par[i+1,]
if (!is.null(checkIntersect(p1,p2,pt,ang))){
print(i)
parcelIndex <- c(parcelIndex,i)
parcelPoints <- rbind(parcelPoints,checkIntersect(p1,p2,pt,ang))
}
}
print(parcelIndex)
##################################################################### Normal case: two intersection points
if (length(parcelIndex) == 2){
opt1 <- array(dim=c(20,2))
opt2 <- array(dim=c(20,2))
A <- parcelIndex[1]
B <- parcelIndex[2]
# Option 1: loop from lower index (A) to higher index (B)
opt1[1,] <- parcelPoints[1,]    # point A
index <- 2
for (i in (A+1):B){
opt1[index,] <- par[i,]
index <- index + 1
}
opt1[index,] <- parcelPoints[2,] # point B
index <- index + 1
opt1[index,] <- parcelPoints[1,]  # back to point A
opt1 <- opt1[which(rowSums(opt1)>0),]
# Option 2: loop from higher index (B) back to lower index (A)
opt2[1,] <- parcelPoints[2,] # point B
index <- 2
i <- B + 1
if (i > dim(par)[1]){   # If B is the last index, adjust i to 1
i <- 1
}
while (i != A){
opt2[index,] <- par[i,]
i <- i + 1
if (i > dim(par)[1]){
i <- 1
}
}
opt2[index,] <- parcelPoints[1,] # point A
index <- index + 1
opt2[index,] <- parcelPoints[2,] # point B
opt2 <- opt2[which(rowSums(opt2)>0),]
# Check if option 1 goes through front
for (i in 1:dim(opt1)[1]){
# if (isFront1(opt1[i,])){
#   return (opt2)
# }
for (j in 1:dim(front)[1]){
if (isTRUE(all.equal(opt1[i,],front[j,]))){  # If any point is on the front, return option 2
return (opt2)
}
}
}
return (opt1)
}
# Other cases: deal with later
else {print("Abnormal number of intersections")}
}
test <- removeFront(test_par, test_bldg, test_front)
test
eqscplot(test_par)
lines(test_bldg)
lines(test)
# Cut out front yard
# Input: parcel_data, building_data, parcelFront
# Use first and last front edge points to draw a line
# Find point or edge on building that is closest (perpendicular distance)
# Find line equation for front edge of building, then find intersection points on parcel
# Output: new parcel coordinates, array (n by 2)
################### Need to incorporate merge_rings to cut out bldg footprint
removeFront <- function(par, bldg, front){
p_i <- front[1,]
p_f <- front[dim(front)[1],]
minIndex <- 0   # track index for closest point to line
minDist <- 1e99 # track associated minimum distance
for (i in 1:dim(bldg)[1]){
dist <- perpDist(bldg[i,1], bldg[i,2], p_i[1], p_i[2], p_f[1], p_f[2])
if (dist < minDist){
minIndex <- i
minDist <- dist
}
}
print(minIndex)
print(minDist)
# Find parallel line
ang <- atan2((p_f-p_i)[2],(p_f-p_i)[1])/pi*180
pt <- bldg[minIndex,]
print(ang)
print(pt)
# For each line of the parcel, check if intersects with front cut line
# Store (1) index of parcel side and (2) intersection point on parcel
# Usually will be two intersections, but may be more if unusual shape
parcelIndex <- vector("double")
parcelPoints <- array(dim = c(0,2))
for (i in 1:(dim(par)[1]-1)){
p1 <- par[i,]
p2 <- par[i+1,]
if (!is.null(checkIntersect(p1,p2,pt,ang))){
print(i)
parcelIndex <- c(parcelIndex,i)
parcelPoints <- rbind(parcelPoints,checkIntersect(p1,p2,pt,ang))
}
}
print(parcelIndex)
##################################################################### Normal case: two intersection points
if (length(parcelIndex) == 2){
opt1 <- array(dim=c(20,2))
opt2 <- array(dim=c(20,2))
A <- parcelIndex[1]
B <- parcelIndex[2]
# Option 1: loop from lower index (A) to higher index (B)
opt1[1,] <- parcelPoints[1,]    # point A
index <- 2
for (i in (A+1):B){
opt1[index,] <- par[i,]
index <- index + 1
}
opt1[index,] <- parcelPoints[2,] # point B
index <- index + 1
opt1[index,] <- parcelPoints[1,]  # back to point A
opt1 <- opt1[which(rowSums(opt1)>0),]
opt1 <- unique(opt1)
opt1 <- rbind(opt1, opt1[1,])
# Option 2: loop from higher index (B) back to lower index (A)
opt2[1,] <- parcelPoints[2,] # point B
index <- 2
i <- B + 1
if (i > dim(par)[1]){   # If B is the last index, adjust i to 1
i <- 1
}
while (i != A){
opt2[index,] <- par[i,]
i <- i + 1
if (i > dim(par)[1]){
i <- 1
}
}
opt2[index,] <- parcelPoints[1,] # point A
index <- index + 1
opt2[index,] <- parcelPoints[2,] # point B
opt2 <- opt2[which(rowSums(opt2)>0),]
opt2 <- unique(opt2)
opt2 <- rbind(opt2, opt2[1,])
# Check if option 1 goes through front
for (i in 1:dim(opt1)[1]){
# if (isFront1(opt1[i,])){
#   return (opt2)
# }
for (j in 1:dim(front)[1]){
if (isTRUE(all.equal(opt1[i,],front[j,]))){  # If any point is on the front, return option 2
return (opt2)
}
}
}
return (opt1)
}
# Other cases: deal with later
else {print("Abnormal number of intersections")}
}
test <- removeFront(test_par, test_bldg, test_front)
test
View(indexFront)
indexFront[[905]]
test <- indexFront[[905]]
test[(test[])]
test[(test[])] <- "test"
test
test <- indexFront[[905]]
test <- c(TRUE, TRUE, FALSE, FALSE)
test2 <- cbind(c(0,6,6,0),c(3,3,6,6))
test2[test[]]
test2[test[],]
average(test2[test[],])
mean(test2[test[],])
rowMeans(test2[test[],])
colMeans(test2[test[],])
test <- 5
test[1]
length(test)
test <- NULL
test
test <- 5
test
test <- c(test,7)
yrdy
test
test <- c(TRUE, TRUE, FALSE, FALSE)
test2
test2[(!test[])]
test2[(!test[]),]
test_par
test_indF <- c(TRUE, FALSE, FALSE, FALSE, FALSE, TRUE)
# Function
# ID parcel sides (front, side, back)
# Front edges are in between front points
# Back edge is furthest away (true distance) from front centroid
# If edges somehow tie, select edge that has smallest angle difference
# If 2 edges somehow tie, select randomly between edges. Or if more than two edges, furthest perpendicular distance?
# Inputs: parcel_data, parcelFront, indexFront
# Outputs: string vector that returns "front/side/rear" for each corresponding edge.
# Edge 1 = point1 to point2, edge 2 = point2 to point3, etc. Length of vector is length(parcel_data) - 1.
idEdges <- function(par, indF){
edges <- indF
# sides[(sides[])] <- "Front"
# Find average of front
centF <- colMeans(par[indF[],])
# Find furthest edge (using midpoint)
maxDist <- 0
maxInd <- NULL
for (i in 1:(par(dim)[1]-1)){
if (!indF[i]){       # Test only if not a front edge
edge <- (par[i,] + par[i + 1, ]) / 2
dist2 <- (edge[1]-centF[1])*(edge[1]-centF[1]) + (edge[2]-centF[2])*(edge[2]-centF[2])
# Case 1: further distance, assign new furthest edge
if (dist2 > maxDist){
maxDist <- dist2
maxInd <- i
}
# Case 2: distance matches, keep all furthest edges
else if (dist2 == maxDist){
maxInd <- c(maxInd, i)
}
# Case 3: distance is shorter. Keep moving.
}
}
edges[(edges[])] <- "Front"
edges[maxInd] <- "Rear"
# Anything not yet marked is a side edge
edges[(!edges[])] <- "Side"
}
# Function
# ID parcel sides (front, side, back)
# Front edges are in between front points
# Back edge is furthest away (true distance) from front centroid
# If edges somehow tie, select edge that has smallest angle difference
# If 2 edges somehow tie, select randomly between edges. Or if more than two edges, furthest perpendicular distance?
# Inputs: parcel_data, parcelFront, indexFront
# Outputs: string vector that returns "front/side/rear" for each corresponding edge.
# Edge 1 = point1 to point2, edge 2 = point2 to point3, etc. Length of vector is length(parcel_data) - 1.
idEdges <- function(par, indF){
edges <- indF
# sides[(sides[])] <- "Front"
# Find average of front
centF <- colMeans(par[indF[],])
# Find furthest edge (using midpoint)
maxDist <- 0
maxInd <- NULL
for (i in 1:(par(dim)[1]-1)){
if (!indF[i]){       # Test only if not a front edge
edge <- (par[i,] + par[i + 1, ]) / 2
dist2 <- (edge[1]-centF[1])*(edge[1]-centF[1]) + (edge[2]-centF[2])*(edge[2]-centF[2])
# Case 1: further distance, assign new furthest edge
if (dist2 > maxDist){
maxDist <- dist2
maxInd <- i
}
# Case 2: distance matches, keep all furthest edges
else if (dist2 == maxDist){
maxInd <- c(maxInd, i)
}
# Case 3: distance is shorter. Keep moving.
}
}
edges[(edges[])] <- "Front"
edges[maxInd] <- "Rear"
# Anything not yet marked is a side edge
edges[(!edges[])] <- "Side"
return(edges)
}
idEdges(test_par, test_indF)
# Function
# ID parcel sides (front, side, back)
# Front edges are in between front points
# Back edge is furthest away (true distance) from front centroid
# If edges somehow tie, select edge that has smallest angle difference
# If 2 edges somehow tie, select randomly between edges. Or if more than two edges, furthest perpendicular distance?
# Inputs: parcel_data, parcelFront, indexFront
# Outputs: string vector that returns "front/side/rear" for each corresponding edge.
# Edge 1 = point1 to point2, edge 2 = point2 to point3, etc. Length of vector is length(parcel_data) - 1.
idEdges <- function(par, indF){
edges <- indF
# sides[(sides[])] <- "Front"
# Find average of front
centF <- colMeans(par[indF[],])
# Find furthest edge (using midpoint)
maxDist <- 0
maxInd <- NULL
for (i in 1:(dim(par)[1]-1)){
if (!indF[i]){       # Test only if not a front edge
edge <- (par[i,] + par[i + 1, ]) / 2
dist2 <- (edge[1]-centF[1])*(edge[1]-centF[1]) + (edge[2]-centF[2])*(edge[2]-centF[2])
# Case 1: further distance, assign new furthest edge
if (dist2 > maxDist){
maxDist <- dist2
maxInd <- i
}
# Case 2: distance matches, keep all furthest edges
else if (dist2 == maxDist){
maxInd <- c(maxInd, i)
}
# Case 3: distance is shorter. Keep moving.
}
}
edges[(edges[])] <- "Front"
edges[maxInd] <- "Rear"
# Anything not yet marked is a side edge
edges[(!edges[])] <- "Side"
return(edges)
}
idEdges(test_par, test_indF)
# Function
# ID parcel sides (front, side, back)
# Front edges are in between front points
# Back edge is furthest away (true distance) from front centroid
# If edges somehow tie, select edge that has smallest angle difference
# If 2 edges somehow tie, select randomly between edges. Or if more than two edges, furthest perpendicular distance?
# Inputs: parcel_data, parcelFront, indexFront
# Outputs: string vector that returns "front/side/rear" for each corresponding edge.
# Edge 1 = point1 to point2, edge 2 = point2 to point3, etc. Length of vector is length(parcel_data) - 1.
idEdges <- function(par, indF){
edges <- indF
print(edges)
# sides[(sides[])] <- "Front"
# Find average of front
centF <- colMeans(par[indF[],])
# Find furthest edge (using midpoint)
maxDist <- 0
maxInd <- NULL
for (i in 1:(dim(par)[1]-1)){
if (!indF[i]){       # Test only if not a front edge
edge <- (par[i,] + par[i + 1, ]) / 2
dist2 <- (edge[1]-centF[1])*(edge[1]-centF[1]) + (edge[2]-centF[2])*(edge[2]-centF[2])
# Case 1: further distance, assign new furthest edge
if (dist2 > maxDist){
maxDist <- dist2
maxInd <- i
}
# Case 2: distance matches, keep all furthest edges
else if (dist2 == maxDist){
maxInd <- c(maxInd, i)
}
# Case 3: distance is shorter. Keep moving.
}
}
print(maxInd)
edges[(edges[])] <- "Front"
edges[maxInd] <- "Rear"
# Anything not yet marked is a side edge
edges[(!edges[])] <- "Side"
return(edges)
}
idEdges(test_par, test_indF)
# Function
# ID parcel sides (front, side, back)
# Front edges are in between front points
# Back edge is furthest away (true distance) from front centroid
# If edges somehow tie, select edge that has smallest angle difference
# If 2 edges somehow tie, select randomly between edges. Or if more than two edges, furthest perpendicular distance?
# Inputs: parcel_data, parcelFront, indexFront
# Outputs: string vector that returns "front/side/rear" for each corresponding edge.
# Edge 1 = point1 to point2, edge 2 = point2 to point3, etc. Length of vector is length(parcel_data) - 1.
idEdges <- function(par, indF){
edges <- indF
print(edges)
# sides[(sides[])] <- "Front"
# Find average of front
centF <- colMeans(par[indF[],])
# Find furthest edge (using midpoint)
maxDist <- 0
maxInd <- NULL
for (i in 1:(dim(par)[1]-1)){
if (!indF[i]){       # Test only if not a front edge
edge <- (par[i,] + par[i + 1, ]) / 2
dist2 <- (edge[1]-centF[1])*(edge[1]-centF[1]) + (edge[2]-centF[2])*(edge[2]-centF[2])
# Case 1: further distance, assign new furthest edge
if (dist2 > maxDist){
maxDist <- dist2
maxInd <- i
}
# Case 2: distance matches, keep all furthest edges
else if (dist2 == maxDist){
maxInd <- c(maxInd, i)
}
# Case 3: distance is shorter. Keep moving.
}
}
print(maxInd)
edges[(edges[])] <- "Front"
edges[maxInd] <- "Rear"
# Anything not yet marked is a side edge
edges[!(edges[])] <- "Side"
return(edges)
}
idEdges(test_par, test_indF)
# Function
# ID parcel sides (front, side, back)
# Front edges are in between front points
# Back edge is furthest away (true distance) from front centroid
# If edges somehow tie, select edge that has smallest angle difference
# If 2 edges somehow tie, select randomly between edges. Or if more than two edges, furthest perpendicular distance?
# Inputs: parcel_data, parcelFront, indexFront
# Outputs: string vector that returns "front/side/rear" for each corresponding edge.
# Edge 1 = point1 to point2, edge 2 = point2 to point3, etc. Length of vector is length(parcel_data) - 1.
idEdges <- function(par, indF){
edges <- indF
print(edges)
# sides[(sides[])] <- "Front"
# Find average of front
centF <- colMeans(par[indF[],])
# Find furthest edge (using midpoint)
maxDist <- 0
maxInd <- NULL
for (i in 1:(dim(par)[1]-1)){
if (!indF[i]){       # Test only if not a front edge
edge <- (par[i,] + par[i + 1, ]) / 2
dist2 <- (edge[1]-centF[1])*(edge[1]-centF[1]) + (edge[2]-centF[2])*(edge[2]-centF[2])
# Case 1: further distance, assign new furthest edge
if (dist2 > maxDist){
maxDist <- dist2
maxInd <- i
}
# Case 2: distance matches, keep all furthest edges
else if (dist2 == maxDist){
maxInd <- c(maxInd, i)
}
# Case 3: distance is shorter. Keep moving.
}
}
print(maxInd)
edges[(edges[])] <- "Front"
edges[maxInd] <- "Rear"
# Anything not yet marked is a side edge
edges[(edges[] == "FALSE")] <- "Side"
return(edges)
}
idEdges(test_par, test_indF)
test_indF
test_indF[1] <- FALSE
test_indF
test_par
test_indF <- c(TRUE, TRUE, TRUE, FALSE, FALSE, FALSE)
idEdges(test_par, test_indF)
