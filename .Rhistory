# Extract associated road
roads <- full_json_data$list_roads[[i]]$geometry.coordinates     # Get the list
# Find two closest points on roadway network to parcel centroid
minDist1 <- 1e99
minDist2 <- 1e99
point1 <- vector(length = 2)
point2 <- vector(length = 2)
road_arr <- array(dim = c(0,2))
for (j in 1:length(roads)){
if (typeof(roads[[j]]) == "list"){
for (k in 1:length(roads[[j]])){
road_arr <- rbind(road_arr, drop(roads[[j]][[k]]))
}
} else{
road_arr <- rbind(road_arr, drop(roads[[j]]))
}
}
road_arr <- unique(road_arr)
for (j in 1:dim(road_arr)[1]){
dist <- sqrt((par_cent[1]-road_arr[j,1])^2 + (par_cent[2]-road_arr[j,1])^2)
if (dist < minDist1){
point2 <- point1
minDist2 <- minDist1
point1 <- road_arr[k,]
minDist1 <- dist
}
}
# We now have the angle of the roadway
road_ang <- atan2(point2[2]-point1[2],point2[1]-point1[1])
print(road_ang)
# Find edges within X degrees of parallel to roadway
angles <- cornerStats[[i]]$angles
nearParallel <- (abs(sin(angles - road_ang)) < sqrt(2)/2)
print(nearParallel)
# Check if there are more than one "chunk" (of consecutive edges) that is near parallel
preVal <- FALSE
chunkInd <- vector()
for (j in 1:length(nearParallel)){
if (j == 1 && nearParallel[j]){
chunks[i] <- chunks[i] + 1
chunkInd <- c(chunkInd, j)
}
else if (j == 1 && nearParallel[j] == FALSE){false_chunks[i] <- false_chunks[i] + 1}
else if (preVal == FALSE && nearParallel[j]){
chunks[i] <- chunks[i] + 1
chunkInd <- c(chunkInd, j)
}
else if (preVal && nearParallel[j] == FALSE){
false_chunks[i] <- false_chunks[i] + 1
chunkInd <- c(chunkInd, j - 1)
}
preVal <- nearParallel[j]
}
if (preVal == TRUE){
chunkInd <- c(chunkInd, length(nearParallel))
}
# Case 1: more than one chunk
if (chunks[i] > 1){
chunkCent <- array(dim = c(chunks[i],2)) # Find centroid of each chunk
perpDistCent <- vector(length = chunks[i])
for (j in 1:chunks[i]){
start <- chunkInd[2*j-1]
finish <- chunkInd[2*j]
if (start == finish){
chunkCent[j,] <- parcelFront[[i]][start,]
} else{
chunkCent[j,] <- colMeans(parcelFront[[i]][start:finish,])
}
perpDistCent[j] <- perpDist(chunkCent[j,1],chunkCent[j,2],point1[1],point1[2],point2[1],point2[2])
}
# Find which chunk is the shortest perpendicular dist from roadway
chunkNum <- which(perpDistCent == min(perpDistCent))[1]
start <- chunkInd[2*chunkNum-1]
finish <- chunkInd[2*chunkNum]
print(paste("Start = ", start, "Finish = ", finish))
test <- parcelFront[[i]][start:(finish+1),]
}
# Case 2: one chunk. Just return that
else{
start <- 0
finish <- 0
for (j in 1:length(nearParallel)){
if (nearParallel[j] && start == 0){
start <- j
}
if (!nearParallel[j] && start > 0){
finish <- j - 1
}
}
print(paste("Start = ", start, "Finish = ", finish))
test <- parcelFront[[i]][start:(finish+1),]
}
}
}
chunks <- vector("double", len_json)              # chunks of edges near parallel to road
false_chunks <- vector("double", len_json)        # chunks of edges not near parallel to road
for (i in 1:len_json){
if (isCorner[i]){  # Only modify if it is marked as a corner parcel
print(i)
par_cent <- colMeans(drop(parcel_data[[i]]))      # Get the parcel centroid
# Extract associated road
roads <- full_json_data$list_roads[[i]]$geometry.coordinates     # Get the list
# Find two closest points on roadway network to parcel centroid
minDist1 <- 1e99
minDist2 <- 1e99
point1 <- vector(length = 2)
point2 <- vector(length = 2)
road_arr <- array(dim = c(0,2))
for (j in 1:length(roads)){
if (typeof(roads[[j]]) == "list"){
for (k in 1:length(roads[[j]])){
road_arr <- rbind(road_arr, drop(roads[[j]][[k]]))
}
} else{
road_arr <- rbind(road_arr, drop(roads[[j]]))
}
}
road_arr <- unique(road_arr)
for (j in 1:dim(road_arr)[1]){
dist <- sqrt((par_cent[1]-road_arr[j,1])^2 + (par_cent[2]-road_arr[j,1])^2)
if (dist < minDist1){
point2 <- point1
minDist2 <- minDist1
point1 <- road_arr[k,]
minDist1 <- dist
}
}
# We now have the angle of the roadway
road_ang <- atan2(point2[2]-point1[2],point2[1]-point1[1])
print(road_ang)
# Find edges within X degrees of parallel to roadway
angles <- cornerStats[[i]]$angles
nearParallel <- (abs(sin(angles - road_ang)) < sqrt(2)/2)
print(nearParallel)
# Check if there are more than one "chunk" (of consecutive edges) that is near parallel
preVal <- FALSE
chunkInd <- vector()
for (j in 1:length(nearParallel)){
if (j == 1 && nearParallel[j]){
chunks[i] <- chunks[i] + 1
chunkInd <- c(chunkInd, j)
}
else if (j == 1 && nearParallel[j] == FALSE){false_chunks[i] <- false_chunks[i] + 1}
else if (preVal == FALSE && nearParallel[j]){
chunks[i] <- chunks[i] + 1
chunkInd <- c(chunkInd, j)
}
else if (preVal && nearParallel[j] == FALSE){
false_chunks[i] <- false_chunks[i] + 1
chunkInd <- c(chunkInd, j - 1)
}
preVal <- nearParallel[j]
}
if (preVal == TRUE){
chunkInd <- c(chunkInd, length(nearParallel))
}
# Case 1: more than one chunk
if (chunks[i] > 1){
chunkCent <- array(dim = c(chunks[i],2)) # Find centroid of each chunk
perpDistCent <- vector(length = chunks[i])
for (j in 1:chunks[i]){
start <- chunkInd[2*j-1]
finish <- chunkInd[2*j]
if (start == finish){
chunkCent[j,] <- parcelFront[[i]][start,]
} else{
chunkCent[j,] <- colMeans(parcelFront[[i]][start:finish,])
}
perpDistCent[j] <- perpDist(chunkCent[j,1],chunkCent[j,2],point1[1],point1[2],point2[1],point2[2])
}
# Find which chunk is the shortest perpendicular dist from roadway
chunkNum <- which(perpDistCent == min(perpDistCent))[1]
start <- chunkInd[2*chunkNum-1]
finish <- chunkInd[2*chunkNum]
print(paste("Start = ", start, "Finish = ", finish))
test <- parcelFront[[i]][start:(finish+1),]
}
# Case 2: one chunk. Just return that
else{
print(paste("Start = ", start, "Finish = ", finish))
test <- parcelFront[[i]][start:(finish+1),]
}
}
}
chunks <- vector("double", len_json)              # chunks of edges near parallel to road
false_chunks <- vector("double", len_json)        # chunks of edges not near parallel to road
for (i in 1:len_json){
if (isCorner[i]){  # Only modify if it is marked as a corner parcel
print(i)
par_cent <- colMeans(drop(parcel_data[[i]]))      # Get the parcel centroid
# Extract associated road
roads <- full_json_data$list_roads[[i]]$geometry.coordinates     # Get the list
# Find two closest points on roadway network to parcel centroid
minDist1 <- 1e99
minDist2 <- 1e99
point1 <- vector(length = 2)
point2 <- vector(length = 2)
road_arr <- array(dim = c(0,2))
for (j in 1:length(roads)){
if (typeof(roads[[j]]) == "list"){
for (k in 1:length(roads[[j]])){
road_arr <- rbind(road_arr, drop(roads[[j]][[k]]))
}
} else{
road_arr <- rbind(road_arr, drop(roads[[j]]))
}
}
road_arr <- unique(road_arr)
for (j in 1:dim(road_arr)[1]){
dist <- sqrt((par_cent[1]-road_arr[j,1])^2 + (par_cent[2]-road_arr[j,1])^2)
if (dist < minDist1){
point2 <- point1
minDist2 <- minDist1
point1 <- road_arr[k,]
minDist1 <- dist
}
}
# We now have the angle of the roadway
road_ang <- atan2(point2[2]-point1[2],point2[1]-point1[1])
print(road_ang)
# Find edges within X degrees of parallel to roadway
angles <- cornerStats[[i]]$angles
nearParallel <- (abs(sin(angles - road_ang)) < sqrt(2)/2)
print(nearParallel)
# Check if there are more than one "chunk" (of consecutive edges) that is near parallel
preVal <- FALSE
chunkInd <- vector()
for (j in 1:length(nearParallel)){
if (j == 1 && nearParallel[j]){
chunks[i] <- chunks[i] + 1
chunkInd <- c(chunkInd, j)
}
else if (j == 1 && nearParallel[j] == FALSE){false_chunks[i] <- false_chunks[i] + 1}
else if (preVal == FALSE && nearParallel[j]){
chunks[i] <- chunks[i] + 1
chunkInd <- c(chunkInd, j)
}
else if (preVal && nearParallel[j] == FALSE){
false_chunks[i] <- false_chunks[i] + 1
chunkInd <- c(chunkInd, j - 1)
}
preVal <- nearParallel[j]
}
if (preVal == TRUE){
chunkInd <- c(chunkInd, length(nearParallel))
}
# Case 1: more than one chunk
if (chunks[i] > 1){
chunkCent <- array(dim = c(chunks[i],2)) # Find centroid of each chunk
perpDistCent <- vector(length = chunks[i])
for (j in 1:chunks[i]){
start <- chunkInd[2*j-1]
finish <- chunkInd[2*j]
if (start == finish){
chunkCent[j,] <- parcelFront[[i]][start,]
} else{
chunkCent[j,] <- colMeans(parcelFront[[i]][start:finish,])
}
perpDistCent[j] <- perpDist(chunkCent[j,1],chunkCent[j,2],point1[1],point1[2],point2[1],point2[2])
}
# Find which chunk is the shortest perpendicular dist from roadway
chunkNum <- which(perpDistCent == min(perpDistCent))[1]
start <- chunkInd[2*chunkNum-1]
finish <- chunkInd[2*chunkNum]
print(paste("Start = ", start, "Finish = ", finish))
test <- parcelFront[[i]][start:(finish+1),]
}
# Case 2: one chunk. Just return that
else{
start <- chunkInd[1]
finish <- chunkInd[2]
print(paste("Start = ", start, "Finish = ", finish))
test <- parcelFront[[i]][start:(finish+1),]
}
}
}
View(full_json_data$list_roads[[33]]$geometry.coordinates)
View(full_json_data$list_roads[[33]])
View(full_json_data$list_roads[[33]]$geometry.coordinates)
test <- full_json_data$list_roads[[33]]$geometry.coordinates[[1]]
test <- drop(test)
View(test)
View(unique(test))
chunks <- vector("double", len_json)              # chunks of edges near parallel to road
false_chunks <- vector("double", len_json)        # chunks of edges not near parallel to road
for (i in 1:len_json){
if (isCorner[i]){  # Only modify if it is marked as a corner parcel
print(i)
par_cent <- colMeans(drop(parcel_data[[i]]))      # Get the parcel centroid
# Extract associated road
roads <- full_json_data$list_roads[[i]]$geometry.coordinates     # Get the list
# Find two closest points on roadway network to parcel centroid
minDist1 <- 1e99
minDist2 <- 1e99
point1 <- vector(length = 2)
point2 <- vector(length = 2)
road_arr <- array(dim = c(0,2))
for (j in 1:length(roads)){
if (typeof(roads[[j]]) == "list"){
for (k in 1:length(roads[[j]])){
road_arr <- rbind(road_arr, drop(roads[[j]][[k]]))
}
} else{
road_arr <- rbind(road_arr, drop(roads[[j]]))
}
}
road_arr <- unique(road_arr)
for (j in 1:dim(road_arr)[1]){
dist <- sqrt((par_cent[1]-road_arr[j,1])^2 + (par_cent[2]-road_arr[j,1])^2)
if (dist < minDist1){
point2 <- point1
minDist2 <- minDist1
point1 <- road_arr[j,]
minDist1 <- dist
}
}
# We now have the angle of the roadway
road_ang <- atan2(point2[2]-point1[2],point2[1]-point1[1])
print(road_ang)
# Find edges within X degrees of parallel to roadway
angles <- cornerStats[[i]]$angles
nearParallel <- (abs(sin(angles - road_ang)) < sqrt(2)/2)
print(nearParallel)
# Check if there are more than one "chunk" (of consecutive edges) that is near parallel
preVal <- FALSE
chunkInd <- vector()
for (j in 1:length(nearParallel)){
if (j == 1 && nearParallel[j]){
chunks[i] <- chunks[i] + 1
chunkInd <- c(chunkInd, j)
}
else if (j == 1 && nearParallel[j] == FALSE){false_chunks[i] <- false_chunks[i] + 1}
else if (preVal == FALSE && nearParallel[j]){
chunks[i] <- chunks[i] + 1
chunkInd <- c(chunkInd, j)
}
else if (preVal && nearParallel[j] == FALSE){
false_chunks[i] <- false_chunks[i] + 1
chunkInd <- c(chunkInd, j - 1)
}
preVal <- nearParallel[j]
}
if (preVal == TRUE){
chunkInd <- c(chunkInd, length(nearParallel))
}
# Case 1: more than one chunk
if (chunks[i] > 1){
chunkCent <- array(dim = c(chunks[i],2)) # Find centroid of each chunk
perpDistCent <- vector(length = chunks[i])
for (j in 1:chunks[i]){
start <- chunkInd[2*j-1]
finish <- chunkInd[2*j]
if (start == finish){
chunkCent[j,] <- parcelFront[[i]][start,]
} else{
chunkCent[j,] <- colMeans(parcelFront[[i]][start:finish,])
}
perpDistCent[j] <- perpDist(chunkCent[j,1],chunkCent[j,2],point1[1],point1[2],point2[1],point2[2])
}
# Find which chunk is the shortest perpendicular dist from roadway
chunkNum <- which(perpDistCent == min(perpDistCent))[1]
start <- chunkInd[2*chunkNum-1]
finish <- chunkInd[2*chunkNum]
print(paste("Start = ", start, "Finish = ", finish))
test <- parcelFront[[i]][start:(finish+1),]
}
# Case 2: one chunk. Just return that
else{
start <- chunkInd[1]
finish <- chunkInd[2]
print(paste("Start = ", start, "Finish = ", finish))
test <- parcelFront[[i]][start:(finish+1),]
}
}
}
eqscplot(json_data[[1711]], type='l')
points(parcelFront[[1711]])
modParcelFront <- parcelFront
chunks <- vector("double", len_json)              # chunks of edges near parallel to road
false_chunks <- vector("double", len_json)        # chunks of edges not near parallel to road
modParcelFront <- parcelFront
for (i in 1:len_json){
if (isCorner[i]){  # Only modify if it is marked as a corner parcel
print(i)
par_cent <- colMeans(drop(parcel_data[[i]]))      # Get the parcel centroid
# Extract associated road
roads <- full_json_data$list_roads[[i]]$geometry.coordinates     # Get the list
# Find two closest points on roadway network to parcel centroid
minDist1 <- 1e99
minDist2 <- 1e99
point1 <- vector(length = 2)
point2 <- vector(length = 2)
road_arr <- array(dim = c(0,2))
for (j in 1:length(roads)){
if (typeof(roads[[j]]) == "list"){
for (k in 1:length(roads[[j]])){
road_arr <- rbind(road_arr, drop(roads[[j]][[k]]))
}
} else{
road_arr <- rbind(road_arr, drop(roads[[j]]))
}
}
road_arr <- unique(road_arr)
for (j in 1:dim(road_arr)[1]){
dist <- sqrt((par_cent[1]-road_arr[j,1])^2 + (par_cent[2]-road_arr[j,1])^2)
if (dist < minDist1){
point2 <- point1
minDist2 <- minDist1
point1 <- road_arr[j,]
minDist1 <- dist
}
}
# We now have the angle of the roadway
road_ang <- atan2(point2[2]-point1[2],point2[1]-point1[1])
print(road_ang)
# Find edges within X degrees of parallel to roadway
angles <- cornerStats[[i]]$angles
nearParallel <- (abs(sin(angles - road_ang)) < sqrt(2)/2)
print(nearParallel)
# Check if there are more than one "chunk" (of consecutive edges) that is near parallel
preVal <- FALSE
chunkInd <- vector()
for (j in 1:length(nearParallel)){
if (j == 1 && nearParallel[j]){
chunks[i] <- chunks[i] + 1
chunkInd <- c(chunkInd, j)
}
else if (j == 1 && nearParallel[j] == FALSE){false_chunks[i] <- false_chunks[i] + 1}
else if (preVal == FALSE && nearParallel[j]){
chunks[i] <- chunks[i] + 1
chunkInd <- c(chunkInd, j)
}
else if (preVal && nearParallel[j] == FALSE){
false_chunks[i] <- false_chunks[i] + 1
chunkInd <- c(chunkInd, j - 1)
}
preVal <- nearParallel[j]
}
if (preVal == TRUE){
chunkInd <- c(chunkInd, length(nearParallel))
}
# Case 1: more than one chunk
if (chunks[i] > 1){
chunkCent <- array(dim = c(chunks[i],2)) # Find centroid of each chunk
perpDistCent <- vector(length = chunks[i])
for (j in 1:chunks[i]){
start <- chunkInd[2*j-1]
finish <- chunkInd[2*j]
if (start == finish){
chunkCent[j,] <- parcelFront[[i]][start,]
} else{
chunkCent[j,] <- colMeans(parcelFront[[i]][start:finish,])
}
perpDistCent[j] <- perpDist(chunkCent[j,1],chunkCent[j,2],point1[1],point1[2],point2[1],point2[2])
}
# Find which chunk is the shortest perpendicular dist from roadway
chunkNum <- which(perpDistCent == min(perpDistCent))[1]
start <- chunkInd[2*chunkNum-1]
finish <- chunkInd[2*chunkNum]
print(paste("Start = ", start, "Finish = ", finish))
modParcelFront[[i]] <- parcelFront[[i]][start:(finish+1),]
}
# Case 2: one chunk. Just return that
else{
start <- chunkInd[1]
finish <- chunkInd[2]
print(paste("Start = ", start, "Finish = ", finish))
modParcelFront[[i]] <- parcelFront[[i]][start:(finish+1),]
}
}
}
View(isCorner)
eqscplot(json_data[[6]], type='l')
points(modParcelFront[[6]])
checkCorner <- function(index){
eqscplot(json_data[[index]],type='l')
points(modParcelFront[[index]])
}
checkCorner(22)
checkCorner(33)
checkCorner(39)
checkCorner(50)
checkCorner(52)
checkCorner(75)
checkCorner(98)
checkCorner(105)
checkCorner(137)
checkCorner(144)
checkCorner(151)
checkCorner(153)
checkCorner(166)
test <- c(TRUE, TRUE, FALSE, TRUE)
for (i in test){}
for (i in test){print(i)}
for (i in (test)){print(i)}
for (i in (test == TRUE)){print(i)}
for (i in 1:len_json){
if (isCorner[i]){
eqscplot(json_data[[i]],type='l')
points(modParcelFront[[i]])
Sys.sleep(0.05)  # Pause and continues automatically
# invisible(readline(prompt="Press [enter] to continue"))  # Manually press enter to continue
}
}
for (i in 1:len_json){
if (isCorner[i]){
eqscplot(json_data[[i]],type='l')
points(modParcelFront[[i]])
Sys.sleep(0.1)  # Pause and continues automatically
# invisible(readline(prompt="Press [enter] to continue"))  # Manually press enter to continue
}
}
