json_block_data[[i]] <- drop(json_block_data[[i]])
}
json_block_length <- 0
for(i in 1:length(json_block_data)){
json_block_length <- json_block_length + dim(json_block_data[[i]])[1]
}
json_block_points <- array(data = 0, dim = c(json_block_length, 2))
index <- 1
for(i in 1:length(json_block_data)){
for(j in 1:dim(json_block_data[[i]])[1]){
json_block_points[index,] <- json_block_data[[i]][j,]
index <- index + 1
}
}
json_block <- "epaparcels_dissolved/Vertices.geojson"
json_block_data <- fromJSON(txt=json_block, flatten = TRUE, simplifyDataFrame = TRUE, simplifyMatrix = TRUE)
View(json_block_data)
View(json_block_data$features$geometry.coordinates)
json_block <- "epaparcels_dissolved/Vertices.geojson"
json_block_data <- fromJSON(txt=json_block, flatten = TRUE, simplifyDataFrame = TRUE, simplifyMatrix = TRUE)
View(json_block_data$features$geometry.coordinates)
json_block_data <- json_block_data$features$geometry.coordinates
View(json_block_data)
json_block_length <- length(json_block_data)
json_block_points <- array(data = 0, dim = c(json_block_length, 2))
json_block_data[[1]]
dim(json_block_data[[1]])
dim(json_block_data[[1]][])
c(json_block_data[[1]][1],json_block_data[[1]][2])
dim(c(json_block_data[[1]][1],json_block_data[[1]][2]))
json_block_length <- length(json_block_data)
json_block_points <- array(data = 0, dim = c(json_block_length, 2))
for(i in 1:json_block_length){
json_block_points[i,1] <- json_block_data[[i]][1]
json_block_points[i,2] <- json_block_data[[i]][2]
}
json_block_data[[1]][1]
json_block_points[1,1]
json_block_data[[2]]
is.null(json_block_data[[2]])
for(i in 1:json_block_length){
if(is.null(json_block_data[[i]])){next}
json_block_points[i,1] <- json_block_data[[i]][1]
json_block_points[i,2] <- json_block_data[[i]][2]
}
View(json_block_points)
json_block_points[json_block_points[,1]==0]
json_block_points[json_block_points[,1]!=0]
json_block_points <- json_block_points[json_block_points[,1]!=0]
json_block_length <- length(json_block_data)
json_block_points <- array(data = 0, dim = c(json_block_length, 2))
for(i in 1:json_block_length){
if(is.null(json_block_data[[i]])){next}
json_block_points[i,1] <- json_block_data[[i]][1]
json_block_points[i,2] <- json_block_data[[i]][2]
}
json_block_points[,-1]
json_block_points <- json_block_points[json_block_points[,1] != 0,]
test <- json_block_points[order(json_block_points[1]),]
test <- json_block_points[order(json_block_points[1])]
test <- json_block_points[order(json_block_points[1,]),]
View(test)
test <- json_block_points[order(json_block_points[,1]),]
View(test)
test <- json_block_points[order( json_block_points[,1], json_block_points[,2]),]
View(test)
json_block_points <- json_block_points[order( json_block_points[,1], json_block_points[,2]),]
x <- rnorm(10000)
v <- x[500]
binary_search(x,v)
install.packages("Rfast")
?findInterval()
findInterval(x,v)
findInterval(v,x)
findInterval(v,sort(x))
v
x <- sort(x)
x[6611]
# Check if merge ring cuts at the front
# Inputs two points (x, y coordinate 1 x 2 vector)
# Outputs a boolean
isFront <- function(point1, point2){
# Check if point1 matches json_block_data
index <- findInterval(point1[1], json_block_points[,1])
while(point1[1] == json_block_points[index,1]){         # search all coordinates w/ same X coord
if(point1[2] == json_block_points[index,2]){return TRUE}
index <- index + 1
}
# Check if point2 matches json_block_data
index <- findInterval(point2[1], json_block_points[,1])
while(point2[1] == json_block_points[index,1]){         # search all coordinates w/ same X coord
if(point2[2] == json_block_points[index,2]){return TRUE}
index <- index + 1
}
# for (i in 1:json_block_length){
#   if(isTRUE(all.equal(point1, json_block_points[i,])) || isTRUE(all.equal(point2, json_block_points[i,]))){
#     return(TRUE)
#   }
# }
# If nothing returns true, return false
return(FALSE)
}
# Check if merge ring cuts at the front
# Inputs two points (x, y coordinate 1 x 2 vector)
# Outputs a boolean
isFront <- function(point1, point2){
# Check if point1 matches json_block_data
index <- findInterval(point1[1], json_block_points[,1])
while(point1[1] == json_block_points[index,1]){         # search all coordinates w/ same X coord
if(point1[2] == json_block_points[index,2]){return(TRUE)}
index <- index + 1
}
# Check if point2 matches json_block_data
index <- findInterval(point2[1], json_block_points[,1])
while(point2[1] == json_block_points[index,1]){         # search all coordinates w/ same X coord
if(point2[2] == json_block_points[index,2]){return(TRUE)}
index <- index + 1
}
# for (i in 1:json_block_length){
#   if(isTRUE(all.equal(point1, json_block_points[i,])) || isTRUE(all.equal(point2, json_block_points[i,]))){
#     return(TRUE)
#   }
# }
# If nothing returns true, return false
return(FALSE)
}
isFront(all_merged_rings[[4]][[2]])
isFront(all_merged_rings[[4]][[1]], all_merged_rings[[4]][[2]])
all_merged_rings[[4]][[1]]
isFront(all_merged_rings[[4]][[1]][1,],all_merged_rings[[4]][[1]][2,])
all_merged_rings[[4]][[1]][1,]
all_merged_rings <- vector("list", len_json)
manualJSON <- array(dim = c(len_json, 2))
jsonIndex <- 1
for(a in 1:len_json) {
all_merged_rings[[a]] <- NA
print(a)
# Check the type of data: double (aka array) or list
arr <- drop(json_data[[a]]) # gets rid of dimensions of 1 length
if (typeof(json_data[[a]]) == "double") { # is an array [a x b x c]
if(length(dim(arr)) == 3 && dim(arr)[1] == 2 && dim(arr)[3] == 2) { # if array is [2 x b x 2]
ring1 <- arr[1,,]
ring2 <- arr[2,,]
all_merged_rings[[a]] <- merge_rings(ring1,ring2,TRUE)
# all_merged_rings[[a]] <- 1
}
else if (length(dim(arr)) == 2 && dim(arr)[2] == 2){    # if is just one polygon, return that polygon
all_merged_rings[[a]] <- arr
}
else if (length(dim(arr)) == 3 && dim(arr)[1] > 2 && dim(arr)[3] == 2){ # if array is [a x b x 2] where a > 2
all_merged_rings[[a]] <- unpackArray(arr)
}
else {
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "nonconforming array"
jsonIndex <- jsonIndex + 1
}
}
else if (typeof(json_data[[a]]) == "list") {
if (length(json_data[[a]]) > 5){
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "long list"
} else{all_merged_rings[[a]] <- unpackList(json_data[[a]])}
}
else{
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "other error"
jsonIndex <- jsonIndex + 1
}
}
all_merged_rings <- vector("list", len_json)
manualJSON <- array(dim = c(len_json, 2))
jsonIndex <- 1
for(a in 1:len_json) {
all_merged_rings[[a]] <- NA
print(a)
# Check the type of data: double (aka array) or list
arr <- drop(json_data[[a]]) # gets rid of dimensions of 1 length
if (typeof(json_data[[a]]) == "double") { # is an array [a x b x c]
if(length(dim(arr)) == 3 && dim(arr)[1] == 2 && dim(arr)[3] == 2) { # if array is [2 x b x 2]
ring1 <- arr[1,,]
ring2 <- arr[2,,]
all_merged_rings[[a]] <- merge_rings(ring1,ring2,TRUE)
# all_merged_rings[[a]] <- 1
}
else if (length(dim(arr)) == 2 && dim(arr)[2] == 2){    # if is just one polygon, return that polygon
all_merged_rings[[a]] <- arr
}
else if (length(dim(arr)) == 3 && dim(arr)[1] > 2 && dim(arr)[3] == 2){ # if array is [a x b x 2] where a > 2
all_merged_rings[[a]] <- unpackArray(arr)
}
else {
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "nonconforming array"
jsonIndex <- jsonIndex + 1
}
}
else if (typeof(json_data[[a]]) == "list") {
if (length(json_data[[a]]) > 5){
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "long list"
} else{all_merged_rings[[a]] <- unpackList(json_data[[a]])}
}
else{
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "other error"
jsonIndex <- jsonIndex + 1
}
}
# Check if merge ring cuts at the front
# Inputs two points (x, y coordinate 1 x 2 vector)
# Outputs a boolean
isFront <- function(point1, point2){
# Check if point1 matches json_block_data
index <- findInterval(point1[1], json_block_points[,1])
while(point1[1] == json_block_points[index,1]){         # search all coordinates w/ same X coord
if(point1[2] == json_block_points[index,2]){return(TRUE)}
index <- index + 1
}
# Check if point2 matches json_block_data
index <- findInterval(point2[1], json_block_points[,1])
while(point2[1] == json_block_points[index,1]){         # search all coordinates w/ same X coord
if(point2[2] == json_block_points[index,2]){return(TRUE)}
index <- index + 1
}
# for (i in 1:json_block_length){
#   if(isTRUE(all.equal(point1, json_block_points[i,])) || isTRUE(all.equal(point2, json_block_points[i,]))){
#     return(TRUE)
#   }
# }
# If nothing returns true, return false
return(FALSE)
}
# ring1 and ring2 are arrays of dim [x, 2] AND/OR lists of already merged rings
# Function is recursively to merge rings if list(s) is passed as an input
# returns list of merged rings
merge_rings <- function(ringA, ringB, frontCut = FALSE){
result <- list()
if (typeof(ringA) == "list"){
indexA <- length(ringA)
} else{indexA <- 1}
if (typeof(ringB) == "list"){
indexB <- length(ringB)
} else{indexB <- 1}
# Case 1: ringA is a list, ringB is an array
if (indexA > 1 && indexB == 1){   #check if there are any lists
for(j in 1:indexA){
result <- append(result, merge_rings(ringA[[j]], ringB, FALSE))
}
}
# Case 2: ringB is a list, ringA is an array
else if (indexA == 1 && indexB > 1){
for(k in 1:indexB){
result <- append(result, merge_rings(ringA, ringB[[k]], FALSE))
}
}
# Case 3: ringA and ringB are both lists
else if (indexA > 1 && indexB > 1){
for(j in 1:indexA){
for(k in 1:indexB){
result <- append(result, merge_rings(ringA[[j]], ringB[[k]], FALSE))
}
}
}
# Base Case: ringA and ringB are arrays
# ring2 is the polygon with fewer points
# ring1 is the polygon with more points
else{
if (length(ringA[,1]) <= length(ringB[,1])){
ring2 <- ringA
ring1 <- ringB
} else {
ring1 <- ringA
ring2 <- ringB
}
len_r1 <- length(ring1[,1])-1  #don't need to consider last point, which is the same as point 1
len_r2 <- length(ring2[,1])-1  #don't need to consider last point, which is the same as point 1
# find all pairs of closest points
ring2_closest <- vector("double", len_r2)
# cycle through each ring1 point
for(m in 1:len_r2){
#returns index of closest ring2 point to current ring1 point
min_dist <- 1e99 #start with a very high number
min_index <- 0   #start with index 0 (not in the index)
for (n in 1:len_r1) {
dx <- abs(ring2[m,1]-ring1[n,1])
dy <- abs(ring2[m,2]-ring1[n,2])
dist <- sqrt(dx*dx+dy*dy)
if (dist < min_dist) {
min_dist <- dist
min_index <- n
}
}
# saves index of closest ring2 point
ring2_closest[m] <- min_index
}
cutIndex <- vector(mode = "logical", len_r2)
cutIndex[] <- TRUE
if (frontCut){
# ID the indices for points on ring1 and ring2 for the cuts after confirming that it goes through the front
cutIndex[] <- FALSE
# Filter index to get cuts that go through the front
for(m in 1:len_r2){
# index1 = m
point1 <- ring2[m,]
index2 <- ring2_closest[m]
point2 <- ring1[ring2_closest[m],]
if (isFront(point1, point2)) {
cutIndex[m] <- TRUE
}
}
# Remove empty rows
if(sum(cutIndex) == 0){                     # If no matches for front cut, switch to no front cut
frontCut <- FALSE
cutIndex[] <- TRUE                        #
}
}
result <- vector("list", len_r2)
for(i in 1:len_r2){
if(cutIndex[i] == FALSE){next}
# merge rings for 1 iteration
ring_merge <- cbind(vector("double", len_r1+len_r2+3),vector("double", len_r1+len_r2+3))
index_merge <- 1   # keep track of index in ring_merge
index2 <- i        # keep track of index in ring2
# add ring1 to ring_merge
for(m in 1:len_r2){
ring_merge[index_merge,1] <- ring2[index2,1]  # transfer value
ring_merge[index_merge,2] <- ring2[index2,2]  # transfer value
index2 <- index2 %% len_r2 + 1 #increment, if at end of index, loops back to 1
index_merge <- index_merge + 1 #increment, no need to loop back
}
#add last point to close ring2
ring_merge[index_merge,1] <- ring2[index2,1]
ring_merge[index_merge,2] <- ring2[index2,2]
index_merge <- index_merge + 1
#add ring2 to ring_merge
index1 <- ring2_closest[index2]
for(n in 1:len_r1){
ring_merge[index_merge,1] <- ring1[index1,1]  # transfer value
ring_merge[index_merge,2] <- ring1[index1,2]  # transfer value
index1 <- index1 - 1 #increment, if at end of index, loops back to 1
if (index1 == 0) {index1 <- len_r1}
index_merge <- index_merge + 1 #increment, no need to loop back
}
ring_merge[index_merge,1] <- ring1[index1,1]
ring_merge[index_merge,2] <- ring1[index1,2]
index_merge <- index_merge + 1
ring_merge[index_merge,1] <- ring2[index2,1]
ring_merge[index_merge,2] <- ring2[index2,2]
result[[i]] <- ring_merge
}
if(frontCut){                   # remove empty indices
result <- result[cutIndex]
}
if (length(result) == 1){return(result[[1]])} else{return(result)}
}
if (length(result) == 1){return(result[[1]])} else{return(result)}
}
all_merged_rings <- vector("list", len_json)
manualJSON <- array(dim = c(len_json, 2))
jsonIndex <- 1
for(a in 1:len_json) {
all_merged_rings[[a]] <- NA
print(a)
# Check the type of data: double (aka array) or list
arr <- drop(json_data[[a]]) # gets rid of dimensions of 1 length
if (typeof(json_data[[a]]) == "double") { # is an array [a x b x c]
if(length(dim(arr)) == 3 && dim(arr)[1] == 2 && dim(arr)[3] == 2) { # if array is [2 x b x 2]
ring1 <- arr[1,,]
ring2 <- arr[2,,]
all_merged_rings[[a]] <- merge_rings(ring1,ring2,TRUE)
# all_merged_rings[[a]] <- 1
}
else if (length(dim(arr)) == 2 && dim(arr)[2] == 2){    # if is just one polygon, return that polygon
all_merged_rings[[a]] <- arr
}
else if (length(dim(arr)) == 3 && dim(arr)[1] > 2 && dim(arr)[3] == 2){ # if array is [a x b x 2] where a > 2
all_merged_rings[[a]] <- unpackArray(arr)
}
else {
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "nonconforming array"
jsonIndex <- jsonIndex + 1
}
}
else if (typeof(json_data[[a]]) == "list") {
if (length(json_data[[a]]) > 5){
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "long list"
} else{all_merged_rings[[a]] <- unpackList(json_data[[a]])}
}
else{
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "other error"
jsonIndex <- jsonIndex + 1
}
}
View(all_merged_rings)
eqscplot(json_data[[2]][[1]])
json_block <- "epaparcels_dissolved/epaparcels_dissolved_adj.geojson"
json_block_data <- fromJSON(txt=json_block, flatten = TRUE, simplifyDataFrame = TRUE, simplifyMatrix = TRUE)
json_block <- "epaparcels_dissolved/epaparcels_dissolved_adj.geojson"
json_block_data <- fromJSON(txt=json_block, flatten = TRUE, simplifyDataFrame = TRUE, simplifyMatrix = TRUE)
View(json_block_data)
View(json_block_data$features$geometry.coordinates[[1]])
View(json_block_data$features$geometry.coordinates[[1]])
View(json_block_data)
json_block_data <- json_block_data$features$geometry.coordinates[[1]]
View(json_block_data)
json_block_length <- 0
for(i in 1:length(json_block_data)){
json_block_data[[i]] <- drop(json_block_data[[i]])
json_block_length <- json_block_length + dim(json_block_data[[i]])[1]
}
jsonIndex <- 1
jsonIndex <- 1
json_block_points <- array(data = 0, dim = c(json_block_length, 2))
for(i in 1:length(json_block_data)){
for(j in 1:dim(json_block_data[[i]])[1]){
json_block_points[jsonIndex,] <- json_block_data[[i]][j,]
}
}
View(json_block_points)
jsonIndex <- 1
json_block_points <- array(data = 0, dim = c(json_block_length, 2))
for(i in 1:length(json_block_data)){
for(j in 1:dim(json_block_data[[i]])[1]){
json_block_points[jsonIndex,] <- json_block_data[[i]][j,]
jsonIndex <- jsonIndex + 1
}
}
View(json_block_points)
json_block_points <- json_block_points[order( json_block_points[,1], json_block_points[,2]),]
View(json_block_points)
View(listMaxRect)
View(json_data)
test <- unpackList(json_data[[4]])
View(test)
test <- unpackList(json_data[[2]])
View(test)
isFront(json_block_points[1,],json_block_points[2,])
# Check if merge ring cuts at the front
# Inputs two points (x, y coordinate 1 x 2 vector)
# Outputs a boolean
isFront <- function(point1, point2){
# Check if point1 matches json_block_data
index <- findInterval(point1[1], json_block_points[,1])
while(isTRUE(all.equal(point1[1], json_block_points[index,1]))){         # search all coordinates w/ same X coord
if(isTRUE(all.equal(point1[2], json_block_points[index,2]))){return(TRUE)}
index <- index + 1
}
# Check if point2 matches json_block_data
index <- findInterval(point2[1], json_block_points[,1])
while(isTRUE(all.equal(point2[1], json_block_points[index,1]))){         # search all coordinates w/ same X coord
if(isTRUE(all.equal(point2[2], json_block_points[index,2]))){return(TRUE)}
index <- index + 1
}
# for (i in 1:json_block_length){
#   if(isTRUE(all.equal(point1, json_block_points[i,])) || isTRUE(all.equal(point2, json_block_points[i,]))){
#     return(TRUE)
#   }
# }
# If nothing returns true, return false
return(FALSE)
}
isFront(json_block_points[1,],json_block_points[2,])
test <- unpackList(json_data[[4]])
View(test)
test <- unpackList(json_data[[2]])
View(test)
all_merged_rings <- vector("list", len_json)
manualJSON <- array(dim = c(len_json, 2))
jsonIndex <- 1
for(a in 1:len_json) {
all_merged_rings[[a]] <- NA
print(a)
# Check the type of data: double (aka array) or list
arr <- drop(json_data[[a]]) # gets rid of dimensions of 1 length
if (typeof(json_data[[a]]) == "double") { # is an array [a x b x c]
if(length(dim(arr)) == 3 && dim(arr)[1] == 2 && dim(arr)[3] == 2) { # if array is [2 x b x 2]
ring1 <- arr[1,,]
ring2 <- arr[2,,]
all_merged_rings[[a]] <- merge_rings(ring1,ring2,TRUE)
# all_merged_rings[[a]] <- 1
}
else if (length(dim(arr)) == 2 && dim(arr)[2] == 2){    # if is just one polygon, return that polygon
all_merged_rings[[a]] <- arr
}
else if (length(dim(arr)) == 3 && dim(arr)[1] > 2 && dim(arr)[3] == 2){ # if array is [a x b x 2] where a > 2
all_merged_rings[[a]] <- unpackArray(arr)
}
else {
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "nonconforming array"
jsonIndex <- jsonIndex + 1
}
}
else if (typeof(json_data[[a]]) == "list") {
if (length(json_data[[a]]) > 5){
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "long list"
} else{all_merged_rings[[a]] <- unpackList(json_data[[a]])}
}
else{
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "other error"
jsonIndex <- jsonIndex + 1
}
}
View(all_merged_rings)
View(all_merged_rings)
View(manualJSON)
