json_block_data <- fromJSON(txt=json_block, flatten = TRUE, simplifyDataFrame = TRUE, simplifyMatrix = TRUE)
json_block_data <- json_block_data$features$geometry.coordinates[[1]]
json_block_length <- 0
for(i in 1:length(json_block_data)){
json_block_data[[i]] <- drop(json_block_data[[i]])
json_block_length <- json_block_length + dim(json_block_data[[i]])[1]
}
jsonIndex <- 1
json_block_points <- array(data = 0, dim = c(json_block_length, 2))
for(i in 1:length(json_block_data)){
for(j in 1:dim(json_block_data[[i]])[1]){
json_block_points[jsonIndex,] <- json_block_data[[i]][j,]
jsonIndex <- jsonIndex + 1
}
}
json_block_points <- json_block_points[order( json_block_points[,1], json_block_points[,2]),]
# Check if merge ring cuts at the front
# Inputs two points (x, y coordinate 1 x 2 vector)
# Outputs a boolean
isFront <- function(point1, point2){
# Check if point1 matches json_block_data
index <- findInterval(point1[1], json_block_points[,1])
while(isTRUE(all.equal(point1[1], json_block_points[index,1]))){         # search all coordinates w/ same X coord
if(isTRUE(all.equal(point1[2], json_block_points[index,2]))){return(TRUE)}
index <- index + 1
}
# Check if point2 matches json_block_data
index <- findInterval(point2[1], json_block_points[,1])
while(isTRUE(all.equal(point2[1], json_block_points[index,1]))){         # search all coordinates w/ same X coord
if(isTRUE(all.equal(point2[2], json_block_points[index,2]))){return(TRUE)}
index <- index + 1
}
# for (i in 1:json_block_length){
#   if(isTRUE(all.equal(point1, json_block_points[i,])) || isTRUE(all.equal(point2, json_block_points[i,]))){
#     return(TRUE)
#   }
# }
# If nothing returns true, return false
return(FALSE)
}
# ring1 and ring2 are arrays of dim [x, 2] AND/OR lists of already merged rings
# Function is recursively to merge rings if list(s) is passed as an input
# returns list of merged rings
merge_rings <- function(ringA, ringB, frontCut = FALSE){
result <- list()
if (typeof(ringA) == "list"){
indexA <- length(ringA)
} else{indexA <- 1}
if (typeof(ringB) == "list"){
indexB <- length(ringB)
} else{indexB <- 1}
# Case 1: ringA is a list, ringB is an array
if (indexA > 1 && indexB == 1){   #check if there are any lists
for(j in 1:indexA){
result <- append(result, merge_rings(ringA[[j]], ringB, FALSE))
}
}
# Case 2: ringB is a list, ringA is an array
else if (indexA == 1 && indexB > 1){
for(k in 1:indexB){
result <- append(result, merge_rings(ringA, ringB[[k]], FALSE))
}
}
# Case 3: ringA and ringB are both lists
else if (indexA > 1 && indexB > 1){
for(j in 1:indexA){
for(k in 1:indexB){
result <- append(result, merge_rings(ringA[[j]], ringB[[k]], FALSE))
}
}
}
# Base Case: ringA and ringB are arrays
# ring2 is the polygon with fewer points
# ring1 is the polygon with more points
else{
if (length(ringA[,1]) <= length(ringB[,1])){
ring2 <- ringA
ring1 <- ringB
} else {
ring1 <- ringA
ring2 <- ringB
}
len_r1 <- length(ring1[,1])-1  #don't need to consider last point, which is the same as point 1
len_r2 <- length(ring2[,1])-1  #don't need to consider last point, which is the same as point 1
# find all pairs of closest points
ring2_closest <- vector("double", len_r2)
# cycle through each ring1 point
for(m in 1:len_r2){
#returns index of closest ring2 point to current ring1 point
min_dist <- 1e99 #start with a very high number
min_index <- 0   #start with index 0 (not in the index)
for (n in 1:len_r1) {
dx <- abs(ring2[m,1]-ring1[n,1])
dy <- abs(ring2[m,2]-ring1[n,2])
dist <- sqrt(dx*dx+dy*dy)
if (dist < min_dist) {
min_dist <- dist
min_index <- n
}
}
# saves index of closest ring2 point
ring2_closest[m] <- min_index
}
cutIndex <- vector(mode = "logical", len_r2)
cutIndex[] <- TRUE
if (frontCut){
# ID the indices for points on ring1 and ring2 for the cuts after confirming that it goes through the front
cutIndex[] <- FALSE
# Filter index to get cuts that go through the front
for(m in 1:len_r2){
# index1 = m
point1 <- ring2[m,]
index2 <- ring2_closest[m]
point2 <- ring1[ring2_closest[m],]
if (isFront(point1, point2)) {
cutIndex[m] <- TRUE
}
}
# Remove empty rows
if(sum(cutIndex) == 0){                     # If no matches for front cut, switch to no front cut
frontCut <- FALSE
cutIndex[] <- TRUE                        #
}
}
result <- vector("list", len_r2)
for(i in 1:len_r2){
if(cutIndex[i] == FALSE){next}
# merge rings for 1 iteration
ring_merge <- cbind(vector("double", len_r1+len_r2+3),vector("double", len_r1+len_r2+3))
index_merge <- 1   # keep track of index in ring_merge
index2 <- i        # keep track of index in ring2
# add ring1 to ring_merge
for(m in 1:len_r2){
ring_merge[index_merge,1] <- ring2[index2,1]  # transfer value
ring_merge[index_merge,2] <- ring2[index2,2]  # transfer value
index2 <- index2 %% len_r2 + 1 #increment, if at end of index, loops back to 1
index_merge <- index_merge + 1 #increment, no need to loop back
}
#add last point to close ring2
ring_merge[index_merge,1] <- ring2[index2,1]
ring_merge[index_merge,2] <- ring2[index2,2]
index_merge <- index_merge + 1
#add ring2 to ring_merge
index1 <- ring2_closest[index2]
for(n in 1:len_r1){
ring_merge[index_merge,1] <- ring1[index1,1]  # transfer value
ring_merge[index_merge,2] <- ring1[index1,2]  # transfer value
index1 <- index1 - 1 #increment, if at end of index, loops back to 1
if (index1 == 0) {index1 <- len_r1}
index_merge <- index_merge + 1 #increment, no need to loop back
}
ring_merge[index_merge,1] <- ring1[index1,1]
ring_merge[index_merge,2] <- ring1[index1,2]
index_merge <- index_merge + 1
ring_merge[index_merge,1] <- ring2[index2,1]
ring_merge[index_merge,2] <- ring2[index2,2]
result[[i]] <- ring_merge
}
if(frontCut){                   # remove empty indices
result <- result[cutIndex]
}
if (length(result) == 1){return(result[[1]])} else{return(result)}
}
if (length(result) == 1){return(result[[1]])} else{return(result)}
}
# Create recursive function to unpack array with more than 2 polygons
# Takes an array
# Returns a list of merged arrays
# Account for errors
unpackArray <-local({
function(arr) {
dim <- dim(arr)    # get length of first dimension of array
if(length(dim) > 3){
print("Error. Nonconforming array")
return()
}
if(dim[3] == 2){       # add first poly
result <- arr[1,,]
} else{
print("Error")
return()
}
for(i in 2:dim[1]){       # go through list
# check if element is a list or array
result <- merge_rings(result, arr[i,,], TRUE)
}
return(result)
}
})
# Create recursive function to unpack list elements
# Takes a list (maybe of more lists)
# Returns a list of merged arrays
unpackList <-local({
function(lst) {
len <- length(lst)    # get length of list
if(typeof(lst[[1]]) == "list"){
result <- unpackList(lst[[1]])  # initialize result, recursively call function
} else if (typeof(lst[[1]]) == "double"){
arr <- drop(lst[[1]])
if (length(dim(arr)) == 2 && dim(arr)[2] == 2){   # check that array has R x 2 dimensions
result <- arr
}
} else{
print("Error")
return()
}
for(i in 2:len){       # go through list
# check if element is a list or array
if (typeof(lst[[i]]) == "list"){
result <- merge_rings(result, unpackList(lst[[i]]), TRUE) # merge onto existing result, recursively call function
} else if (typeof(lst[[i]]) == "double"){
arr <- drop(lst[[i]])
if (length(dim(arr)) == 2 && dim(arr)[2] == 2){   # check that array has R x 2 dimensions
result <- merge_rings(result, arr, TRUE)                # merge onto existing result
}
} else{
print("Error")
return()
}
}
return(result)
}
})
setwd("~/GitHub/maxrect")
library(maxrectangle)
library(jsonlite)
library(readr)
library(MASS)
library(sp)
json_file <- "epaparcelsnobldg.json"
full_json_data <- fromJSON(txt=json_file, flatten = TRUE, simplifyDataFrame = TRUE)
json_data <- full_json_data$json_geometry.coordinates
len_json <- length(json_data)
# json_block <- "epaparcels_dissolved/Vertices.geojson"
# json_block_data <- fromJSON(txt=json_block, flatten = TRUE, simplifyDataFrame = TRUE, simplifyMatrix = TRUE)
# json_block_data <- json_block_data$features$geometry.coordinates
# json_block_length <- length(json_block_data)
# json_block_points <- array(data = 0, dim = c(json_block_length, 2))
# for(i in 1:json_block_length){
#   if(is.null(json_block_data[[i]])){next}
#   json_block_points[i,1] <- json_block_data[[i]][1]
#   json_block_points[i,2] <- json_block_data[[i]][2]
# }
# json_block_points <- json_block_points[json_block_points[,1] != 0,]
# json_block_points <- json_block_points[order( json_block_points[,1], json_block_points[,2]),]
json_block <- "epaparcels_dissolved/epaparcels_dissolved_adj.geojson"
json_block_data <- fromJSON(txt=json_block, flatten = TRUE, simplifyDataFrame = TRUE, simplifyMatrix = TRUE)
json_block_data <- json_block_data$features$geometry.coordinates[[1]]
json_block_length <- 0
for(i in 1:length(json_block_data)){
json_block_data[[i]] <- drop(json_block_data[[i]])
json_block_length <- json_block_length + dim(json_block_data[[i]])[1]
}
jsonIndex <- 1
json_block_points <- array(data = 0, dim = c(json_block_length, 2))
for(i in 1:length(json_block_data)){
for(j in 1:dim(json_block_data[[i]])[1]){
json_block_points[jsonIndex,] <- json_block_data[[i]][j,]
jsonIndex <- jsonIndex + 1
}
}
json_block_points <- json_block_points[order( json_block_points[,1], json_block_points[,2]),]
# Check if merge ring cuts at the front
# Inputs two points (x, y coordinate 1 x 2 vector)
# Outputs a boolean
isFront <- function(point1, point2){
# Check if point1 matches json_block_data
index <- findInterval(point1[1], json_block_points[,1])
while(isTRUE(all.equal(point1[1], json_block_points[index,1]))){         # search all coordinates w/ same X coord
if(isTRUE(all.equal(point1[2], json_block_points[index,2]))){return(TRUE)}
index <- index + 1
}
# Check if point2 matches json_block_data
index <- findInterval(point2[1], json_block_points[,1])
while(isTRUE(all.equal(point2[1], json_block_points[index,1]))){         # search all coordinates w/ same X coord
if(isTRUE(all.equal(point2[2], json_block_points[index,2]))){return(TRUE)}
index <- index + 1
}
# for (i in 1:json_block_length){
#   if(isTRUE(all.equal(point1, json_block_points[i,])) || isTRUE(all.equal(point2, json_block_points[i,]))){
#     return(TRUE)
#   }
# }
# If nothing returns true, return false
return(FALSE)
}
# ring1 and ring2 are arrays of dim [x, 2] AND/OR lists of already merged rings
# Function is recursively to merge rings if list(s) is passed as an input
# returns list of merged rings
merge_rings <- function(ringA, ringB, frontCut = FALSE){
result <- list()
if (typeof(ringA) == "list"){
indexA <- length(ringA)
} else{indexA <- 1}
if (typeof(ringB) == "list"){
indexB <- length(ringB)
} else{indexB <- 1}
# Case 1: ringA is a list, ringB is an array
if (indexA > 1 && indexB == 1){   #check if there are any lists
for(j in 1:indexA){
result <- append(result, merge_rings(ringA[[j]], ringB, FALSE))
}
}
# Case 2: ringB is a list, ringA is an array
else if (indexA == 1 && indexB > 1){
for(k in 1:indexB){
result <- append(result, merge_rings(ringA, ringB[[k]], FALSE))
}
}
# Case 3: ringA and ringB are both lists
else if (indexA > 1 && indexB > 1){
for(j in 1:indexA){
for(k in 1:indexB){
result <- append(result, merge_rings(ringA[[j]], ringB[[k]], FALSE))
}
}
}
# Base Case: ringA and ringB are arrays
# ring2 is the polygon with fewer points
# ring1 is the polygon with more points
else{
if (length(ringA[,1]) <= length(ringB[,1])){
ring2 <- ringA
ring1 <- ringB
} else {
ring1 <- ringA
ring2 <- ringB
}
len_r1 <- length(ring1[,1])-1  #don't need to consider last point, which is the same as point 1
len_r2 <- length(ring2[,1])-1  #don't need to consider last point, which is the same as point 1
# find all pairs of closest points
ring2_closest <- vector("double", len_r2)
# cycle through each ring1 point
for(m in 1:len_r2){
#returns index of closest ring2 point to current ring1 point
min_dist <- 1e99 #start with a very high number
min_index <- 0   #start with index 0 (not in the index)
for (n in 1:len_r1) {
dx <- abs(ring2[m,1]-ring1[n,1])
dy <- abs(ring2[m,2]-ring1[n,2])
dist <- sqrt(dx*dx+dy*dy)
if (dist < min_dist) {
min_dist <- dist
min_index <- n
}
}
# saves index of closest ring2 point
ring2_closest[m] <- min_index
}
cutIndex <- vector(mode = "logical", len_r2)
cutIndex[] <- TRUE
if (frontCut){
# ID the indices for points on ring1 and ring2 for the cuts after confirming that it goes through the front
cutIndex[] <- FALSE
# Filter index to get cuts that go through the front
for(m in 1:len_r2){
# index1 = m
point1 <- ring2[m,]
index2 <- ring2_closest[m]
point2 <- ring1[ring2_closest[m],]
if (isFront(point1, point2)) {
cutIndex[m] <- TRUE
}
}
# Remove empty rows
if(sum(cutIndex) == 0){                     # If no matches for front cut, switch to no front cut
frontCut <- FALSE
cutIndex[] <- TRUE                        #
}
}
result <- vector("list", len_r2)
for(i in 1:len_r2){
if(cutIndex[i] == FALSE){next}
# merge rings for 1 iteration
ring_merge <- cbind(vector("double", len_r1+len_r2+3),vector("double", len_r1+len_r2+3))
index_merge <- 1   # keep track of index in ring_merge
index2 <- i        # keep track of index in ring2
# add ring1 to ring_merge
for(m in 1:len_r2){
ring_merge[index_merge,1] <- ring2[index2,1]  # transfer value
ring_merge[index_merge,2] <- ring2[index2,2]  # transfer value
index2 <- index2 %% len_r2 + 1 #increment, if at end of index, loops back to 1
index_merge <- index_merge + 1 #increment, no need to loop back
}
#add last point to close ring2
ring_merge[index_merge,1] <- ring2[index2,1]
ring_merge[index_merge,2] <- ring2[index2,2]
index_merge <- index_merge + 1
#add ring2 to ring_merge
index1 <- ring2_closest[index2]
for(n in 1:len_r1){
ring_merge[index_merge,1] <- ring1[index1,1]  # transfer value
ring_merge[index_merge,2] <- ring1[index1,2]  # transfer value
index1 <- index1 - 1 #increment, if at end of index, loops back to 1
if (index1 == 0) {index1 <- len_r1}
index_merge <- index_merge + 1 #increment, no need to loop back
}
ring_merge[index_merge,1] <- ring1[index1,1]
ring_merge[index_merge,2] <- ring1[index1,2]
index_merge <- index_merge + 1
ring_merge[index_merge,1] <- ring2[index2,1]
ring_merge[index_merge,2] <- ring2[index2,2]
result[[i]] <- ring_merge
}
if(frontCut){                   # remove empty indices
result <- result[cutIndex]
}
if (length(result) == 1){return(result[[1]])} else{return(result)}
}
if (length(result) == 1){return(result[[1]])} else{return(result)}
}
# Create recursive function to unpack array with more than 2 polygons
# Takes an array
# Returns a list of merged arrays
# Account for errors
unpackArray <-local({
function(arr) {
dim <- dim(arr)    # get length of first dimension of array
if(length(dim) > 3){
print("Error. Nonconforming array")
return()
}
if(dim[3] == 2){       # add first poly
result <- arr[1,,]
} else{
print("Error")
return()
}
for(i in 2:dim[1]){       # go through list
# check if element is a list or array
result <- merge_rings(result, arr[i,,], TRUE)
}
return(result)
}
})
# Create recursive function to unpack list elements
# Takes a list (maybe of more lists)
# Returns a list of merged arrays
unpackList <-local({
function(lst) {
len <- length(lst)    # get length of list
if(typeof(lst[[1]]) == "list"){
result <- unpackList(lst[[1]])  # initialize result, recursively call function
} else if (typeof(lst[[1]]) == "double"){
arr <- drop(lst[[1]])
if (length(dim(arr)) == 2 && dim(arr)[2] == 2){   # check that array has R x 2 dimensions
result <- arr
}
} else{
print("Error")
return()
}
for(i in 2:len){       # go through list
# check if element is a list or array
if (typeof(lst[[i]]) == "list"){
result <- merge_rings(result, unpackList(lst[[i]]), TRUE) # merge onto existing result, recursively call function
} else if (typeof(lst[[i]]) == "double"){
arr <- drop(lst[[i]])
if (length(dim(arr)) == 2 && dim(arr)[2] == 2){   # check that array has R x 2 dimensions
result <- merge_rings(result, arr, TRUE)                # merge onto existing result
}
} else{
print("Error")
return()
}
}
return(result)
}
})
View(json_data)
View(json_data[[4676]])
all_merged_rings <- vector("list", len_json)
manualJSON <- array(dim = c(len_json, 2))
jsonIndex <- 1
for(a in 1:len_json) {
all_merged_rings[[a]] <- NA
print(a)
# Check the type of data: double (aka array) or list
arr <- drop(json_data[[a]]) # gets rid of dimensions of 1 length
if (typeof(json_data[[a]]) == "double") { # is an array [a x b x c]
if(length(dim(arr)) == 3 && dim(arr)[1] == 2 && dim(arr)[3] == 2) { # if array is [2 x b x 2]
ring1 <- arr[1,,]
ring2 <- arr[2,,]
all_merged_rings[[a]] <- merge_rings(ring1,ring2,TRUE)
# all_merged_rings[[a]] <- 1
}
else if (length(dim(arr)) == 2 && dim(arr)[2] == 2){    # if is just one polygon, return that polygon
all_merged_rings[[a]] <- arr
}
else if (length(dim(arr)) == 3 && dim(arr)[1] > 2 && dim(arr)[3] == 2){ # if array is [a x b x 2] where a > 2
all_merged_rings[[a]] <- unpackArray(arr)
}
else {
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "nonconforming array"
jsonIndex <- jsonIndex + 1
}
}
else if (typeof(json_data[[a]]) == "list") {
if (length(json_data[[a]]) > 5){
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "long list"
jsonIndex <- jsonIndex + 1
} else{all_merged_rings[[a]] <- unpackList(json_data[[a]])}
}
else{
manualJSON[jsonIndex, 1] <- a
manualJSON[jsonIndex, 2] <- "other error"
jsonIndex <- jsonIndex + 1
}
}
View(manualJSON)
