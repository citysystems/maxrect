slope[j] <- atan2(arr[j+1,2]-arr[j,2], arr[j+1,1]-arr[j,1])
}
totslo1 <- atan2(arr[dim(arr)[1],2]-arr[1,2], arr[dim(arr)[1],1]-arr[1,1])
totslo2 <- (totslo1 + pi) %% 2*pi
# Save slopes
cornerStats[[i]]$slopes <- slope
# Average slope
cornerStats[[i]]$avg <- mean(slope)
# Difference in slope between first segment and hypotenuse (first to last point)
cornerStats[[i]]$totdiff1 <- atan2(sin(totslo1-slope[1]),cos(totslo1-slope[1]))
# Difference in slope between last segment and hypotenuse (first to last point)
cornerStats[[i]]$totdiff2 <- atan2(sin(totslo2-slope[length(slope)]+pi),cos(totslo2-slope[length(slope)]+pi))
# Difference in slope between first segment and last segment
cornerStats[[i]]$segdiff <- atan2(sin(slope[length(slope)]-slope[1]), cos(slope[length(slope)]-slope[1]))
}
segDiff <- array(dim = c(numPar,2))
for (i in 1:numPar){
if (is.null(cornerStats[[i]])) {
segDiff[i,1] <- NA
}
else {
segDiff[i,1] <- abs(cornerStats[[i]]$segdiff)/pi*180
}
}
segDiff[,2] <- 1:numPar
colnames(segDiff) <- c("diff", "index")
segDiff <- na.omit(segDiff)
tibble(val = segDiff[,1]) %>%
ggplot(., aes(x = val)) +
geom_histogram(aes(y = cumsum(..count..)/sum(..count..)), binwidth = 5) +
scale_x_reverse(
breaks = seq(-180, 180, 30)
# , limits = c(90, 0)
) +
scale_y_continuous(labels = scales::percent)
totDiff <- array(dim = c(numPar,2))
for (i in 1:numPar){
if (is.null(cornerStats[[i]])) {
totDiff[i,1] <- NA
}
else {
totDiff[i,1] <- abs(min(cornerStats[[i]]$totdiff1, cornerStats[[i]]$totdiff2))/pi*180
}
}
totDiff[,2] <- 1:numPar
colnames(totDiff) <- c("totdiff", "index")
totDiff <- na.omit(totDiff)
tibble(val = totDiff[,1]) %>%
ggplot(., aes(x = val)) +
geom_histogram(aes(y = ..count../sum(..count..)), binwidth = 5) +
scale_y_continuous(labels = scales::percent) #+
# scale_x_continuous(limits = c(0, 90))
isCorner <- vector("logical", numPar)
for (i in 1:numPar){
if (is.null(cornerStats[[i]])) {next}
# if mostly straight, skip   *********************** try taking out this test
# if (abs(cornerStats[[i]]$totdiff1) < (20/180*pi) || abs(cornerStats[[i]]$totdiff2) < (20/180*pi)) {next}
# if first and last segment have more than 60 degrees diff, mark as corner
# if (abs(cornerStats[[i]]$segdiff) >= (40/180*pi)) {isCorner[i] <- TRUE}
else {isCorner[i] <-  TRUE}
}
modParcelFront <- parcelFront
roadway <- vector("list", numPar)
closestRoad <- vector("list", numPar)
slopeDiffs <- vector("double", numPar)
orderRead <- vector("character", numPar)
for (i in 1:numPar){
if (isCorner[i]){  # Only modify if it is marked as a corner parcel
print(i)
par_cent <- colMeans(drop(parcel_data[[i]]))      # Get the parcel centroid
# Extract associated road
roads <- full_parcel_data$list_roads[[i]]$geometry.coordinates     # Get the list
# Find two closest points on roadway network to parcel centroid
minDist1 <- 1e99
minDist2 <- 1e99
point1 <- vector(length = 2)
point2 <- vector(length = 2)
road_arr <- array(dim = c(0,2))
for (j in 1:length(roads)){
if (typeof(roads[[j]]) == "list"){
for (k in 1:length(roads[[j]])){
road_arr <- rbind(road_arr, drop(roads[[j]][[k]]))
}
} else{
road_arr <- rbind(road_arr, drop(roads[[j]]))
}
}
road_arr <- unique(road_arr)
roadway[[i]] <- road_arr
dist <- vector(length = dim(road_arr)[1])
for (j in 1:dim(road_arr)[1]){
dist[j] <- ((par_cent[1]-road_arr[j,1])/100000)^2 + ((par_cent[2]-road_arr[j,2])/100000)^2
}
# print(dist)
ord <- order(dist)
# print(ord)
road_arr <- road_arr[ord,]
point1 <- road_arr[1,]
point2 <- road_arr[2,]
closestRoad[[i]] <- rbind(point1,point2)
# We now have the slope of the roadway
road_slo <- (atan2(point2[2]-point1[2],point2[1]-point1[1]) + 2*pi) %% 2*pi
# print(road_slo)
# Compare first and last front point. ID which one has shortest perp dist to roadway.
first <- parcelFront[[i]][1,]
last <- parcelFront[[i]][dim(parcelFront[[i]])[1],]
distFirst <- perpDist(first[1], first[2], closestRoad[[i]][1,1], closestRoad[[i]][1,2], closestRoad[[i]][2,1], closestRoad[[i]][2,2])
distLast <- perpDist(last[1], last[2], closestRoad[[i]][1,1], closestRoad[[i]][1,2], closestRoad[[i]][2,1], closestRoad[[i]][2,2])
slopes <- cornerStats[[i]]$slopes
# Case 1: First point is closer. Starting from first edge, grab all edges going up to the bisecting slope. If slope difference is less than 90 degrees, go up to 45 degrees
if (distFirst < distLast){
print("First < Last")
orderRead[i] <-  "First < Last"
slopeDiff <- atan2(sin(slopes[length(slopes)] - slopes[1]), cos(slopes[length(slopes)] - slopes[1]))
slopeDiffs[i] <- slopeDiff
if (slopeDiff < 0){
print("slopeDiff < 0")
delta <- max(min(slopeDiff * 0.5, -pi/6), -70/180*pi)  # Add a bit more than half, just as a buffer. Range must be between 45-70 degrees
slopeCut <- atan2(sin(slopes[1] + delta), cos(slopes[1] + delta))
for (j in 1:length(slopes)){
if (atan2(sin(slopes[j]-slopeCut), cos(slopes[j]-slopeCut)) < 0) {  # This edge goes past the threshold
print(j)
modParcelFront[[i]] <- parcelFront[[i]][1:j,]
break
}
# If no edge goes past the threshold, don't need to change anything
}
}
else{
print("slopeDiff >= 0")
delta <- min(max(slopeDiff * 0.5, pi/6), 70/180*pi)
slopeCut <- atan2(sin(slopes[1] + delta), cos(slopes[1] + delta))
for (j in 1:length(slopes)){
if (atan2(sin(slopes[j]-slopeCut), cos(slopes[j]-slopeCut)) > 0) {   # This edge goes past the threshold
print(j)
modParcelFront[[i]] <- parcelFront[[i]][1:j,]
break
}
# If no edge goes past the threshold, don't need to change anything
}
}
}
# Case 2: Last point is closer. Starting from last edge, grad all edges going up to the bisecting slope. If slope difference is less than 90 degrees, go up to 45 degrees
else{
orderRead[i] <- "Last < First"
slopeDiff <- atan2(sin(slopes[1] - slopes[length(slopes)]), cos(slopes[1] - slopes[length(slopes)]))
slopeDiffs[i] <- slopeDiff
if (slopeDiff < 0){
print("slopeDiff < 0")
delta <- max(min(slopeDiff * 0.5, -pi/6), -70/180*pi)  # Add a bit more than half, just as a buffer
slopeCut <- atan2(sin(slopes[length(slopes)] + delta), cos(slopes[length(slopes)] + delta))
for (j in length(slopes):1){
if (atan2(sin(slopes[j]-slopeCut), cos(slopes[j]-slopeCut)) < 0){
print(j)
modParcelFront[[i]] <- parcelFront[[i]][(j+1):(length(slopes)+1),]
break
}
# If no edge goes past the threshold, don't need to change anything
}
}
else{
print("slopeDiff >= 0")
delta <- min(max(slopeDiff * 0.5, pi/6), 70/180*pi)
slopeCut <- atan2(sin(slopes[length(slopes)] + delta), cos(slopes[length(slopes)] + delta))
for (j in length(slopes):1){
if (atan2(sin(slopes[j]-slopeCut), cos(slopes[j]-slopeCut)) > 0){
print(j)
modParcelFront[[i]] <- parcelFront[[i]][(j+1):(length(slopes)+1),]
break
}
# If no edge goes past the threshold, don't need to change anything
}
}
}
# # Find edges within X degrees of parallel to roadway
# slopes <- cornerStats[[i]]$slopes
# nearParallel <- (abs(sin(slopes - road_slo)) < sqrt(2)/2)
# print(nearParallel)
# # Check if there are more than one "chunk" (of consecutive edges) that is near parallel
# preVal <- FALSE
# chunkInd <- vector()
# for (j in 1:length(nearParallel)){
#   if (j == 1 && nearParallel[j]){
#     chunks[i] <- chunks[i] + 1
#     chunkInd <- c(chunkInd, j)
#     }
#   else if (j == 1 && nearParallel[j] == FALSE){false_chunks[i] <- false_chunks[i] + 1}
#   else if (preVal == FALSE && nearParallel[j]){
#     chunks[i] <- chunks[i] + 1
#     chunkInd <- c(chunkInd, j)
#     }
#   else if (preVal && nearParallel[j] == FALSE){
#     false_chunks[i] <- false_chunks[i] + 1
#     chunkInd <- c(chunkInd, j - 1)
#     }
#   preVal <- nearParallel[j]
# }
# if (preVal == TRUE){
#   chunkInd <- c(chunkInd, length(nearParallel))
# }
#
# # Case 1: more than one chunk
# if (chunks[i] > 1){
#   chunkCent <- array(dim = c(chunks[i],2)) # Find centroid of each chunk
#   perpDistCent <- vector(length = chunks[i])
#   for (j in 1:chunks[i]){
#     start <- chunkInd[2*j-1]
#     finish <- chunkInd[2*j]
#     if (start == finish){
#       chunkCent[j,] <- parcelFront[[i]][start,]
#     } else{
#       chunkCent[j,] <- colMeans(parcelFront[[i]][start:finish,])
#     }
#     perpDistCent[j] <- perpDist(chunkCent[j,1],chunkCent[j,2],point1[1],point1[2],point2[1],point2[2])
#   }
#   # Find which chunk is the shortest perpendicular dist from roadway
#   chunkNum <- which(perpDistCent == min(perpDistCent))[1]
#   start <- chunkInd[2*chunkNum-1]
#   finish <- chunkInd[2*chunkNum]
#   print(paste("Start = ", start, "Finish = ", finish))
#   modParcelFront[[i]] <- parcelFront[[i]][start:(finish+1),]
# }
# # Case 2: one chunk. Just return that
# else{
#   start <- chunkInd[1]
#   finish <- chunkInd[2]
#   print(paste("Start = ", start, "Finish = ", finish))
#   modParcelFront[[i]] <- parcelFront[[i]][start:(finish+1),]
# }
}
}
troubleshootRoad <- function(index){
eqscplot(roadway[[index]], type='l')
points(closestRoad[[index]], pch = 19)
points(roadway[[index]], pch = 1)
lines(parcel_data[[index]])
}
for (i in 1:numPar){
if (isCorner[i]){
print(i)
eqscplot(parcel_data[[i]],type='l', tol=0.9)
points(parcelFront[[i]], pch = 1)
text(parcelFront[[i]], labels = row(parcelFront[[i]]), pos = 4, offset = 1)
points(modParcelFront[[i]], pch = 16)
points(closestRoad[[i]])
lines(roadway[[i]])
# Sys.sleep(0.1)  # Pause and continues automatically
invisible(readline(prompt="Press [enter] to continue"))  # Manually press enter to continue
}
}
checkCorner <- function(i){
# Convert matrices to tibbles
tblPar <- as_tibble(parcel_data[[i]])
tblFront <- as_tibble(parcelFront[[i]])
tblModFront <- as_tibble(modParcelFront[[i]])
tblClosestRoad <- as_tibble(closestRoad[[i]])
tblRoadway <- as_tibble(roadway[[i]])
# Get XY limits of parcel
parXMin <- min(tblPar[[1]])
parXMax <- max(tblPar[[1]])
parYMin <- min(tblPar[[2]])
parYMax <- max(tblPar[[2]])
# Adjust the scope of the plot
XMin <- parXMin - (parXMax - parXMin)
XMax <- parXMax + (parXMax - parXMin)
YMin <- parYMin - (parYMax - parYMin)
YMax <- parYMax + (parYMax - parYMin)
# Plot the parcel and points and roadway for user to check
print(
ggplot() +
geom_polygon(data = tblPar, aes(V1, V2), color = 'gray') +
geom_point(data = tblFront, aes(V1, V2), color = 'red', size = 3) +
geom_point(data = tblModFront, aes(V1, V2), color = 'green', size = 3) +
geom_line(data = tblRoadway, aes(V1, V2)) +
geom_line(data = tblClosestRoad, aes(V1, V2), color = 'blue', size = 3) +
geom_label_repel(data = tblFront, aes(V1, V2, label = rownames(tblFront))) +
coord_cartesian(xlim = c(XMin, XMax), ylim = c(YMin, YMax))
)
}
perpDist <- function(x, y, x1, y1, x2, y2){
return (abs((y2-y1) * x - (x2-x1) * y + x2*y1 - y2*x1)/sqrt((y2 - y1)^2 + (x2 - x1)^2))
}
removeFront <- function(par, bldg, front){
p_i <- front[1,]
p_f <- front[dim(front)[1],]
minIndex <- 0   # track index for closest point to line
minDist <- 1e99 # track associated minimum distance
for (i in 1:dim(bldg)[1]){
dist <- perpDist(bldg[i,1], bldg[i,2], p_i[1], p_i[2], p_f[1], p_f[2])
if (dist < minDist){
minIndex <- i
minDist <- dist
}
}
# print(minIndex)
# print(minDist)
# Find parallel line
slope <- atan2((p_f-p_i)[2],(p_f-p_i)[1])
pt <- bldg[minIndex,]
r_slope <- c(cos(slope),sin(slope))
return (c(pt, r_slope))
}
distPtLineSeg <- function(x, y, x1, y1, x2, y2){
A <- x - x1
B <- y - y1
C <- x2 - x1
D <- y2 - y1
dot <- A * C + B * D
len_sq <- C * C + D * D
param <- -1
if (len_sq != 0){  # in case of 0 length line
param <- dot / len_sq
}
xx <- 0
yy <- 0
if (param < 0){
xx <- x2
yy <- y1
}
else if (param > 1){
xx <- x2
yy <- y2
}
else{
xx = x1 + param * C
yy = y1 + param * D
}
dx <- x - xx
dy <- y - yy
return (sqrt(dx * dx + dy * dy))
}
checkIntersect <- function(p1, p2, pt, slope) {
q <- p1
s <- p2 - p1
# if (s[1]*s[1]+s[2]*s[2] < 1e-5) {return (FALSE)} # if two points are too close together,
p <- pt
r <- c(cos(slope / 180 * pi), sin(slope / 180 * pi))
if (crossprod2D(r, s) == 0) {
# lines are parallel and do not intersect
return(NULL)
}
t <- crossprod2D((q - p), s) / crossprod2D(r, s)
u <- crossprod2D((q - p), r) / crossprod2D(r, s)
if (u <= 1 && u >= 0) {
return(p + t * r)
}
else
return(NULL)
}
intersectLines <- function(line1, line2) {
p <- c(line1[1],line1[2])
r <- c(line1[3],line1[4])
q <- c(line2[1],line2[2])
s <- c(line2[3],line2[4])
# if (s[1]*s[1]+s[2]*s[2] < 1e-5) {return (FALSE)} # if two points are too close together,
if (crossprod2D(r, s) == 0) {
# lines are parallel and do not intersect
return(NULL)
}
t <- crossprod2D((q - p), s) / crossprod2D(r, s)
u <- crossprod2D((q - p), r) / crossprod2D(r, s)
return(p + t * r)
}
crossprod2D <- function(u, v){
return(u[1]*v[2]-u[2]*v[1])
}
allBuffers <- function(par, edges, bldg, front, side_dist, rear_dist, bldg_dist = 0){
buffers <- array(dim = c(0, 4))
skipFront <- FALSE               # Keep track of whether front cut was already added. If so, skip other front edges
# Find the lines for all the buffers
for (i in 1:length(edges)){
if (edges[i] == "Front"){
if (skipFront){
next
}
else{
buffers <- rbind(buffers, removeFront(par, bldg, front))
skipFront <- TRUE
}
}
else if (edges[i] == "Side"){
buffers <- rbind(buffers, buffer(par, i, side_dist))
}
else if (edges[i] == "Rear"){
buffers <- rbind(buffers, buffer(par, i, rear_dist))
}
}
buffers <- rbind(buffers, buffers[1,])      # Wrap around for easier looping later
newPar <- array(dim = c((length(edges)+1), 2))
for (i in 1:length(edges)){
newPar[i,] <- intersectLines(buffers[i,],buffers[i+1,])
}
newPar[length(edges)+1,] <- newPar[1,]
# print("test")
# Check if new parcel has any intersections due to buffers overtaking edge(s)
# Use st_is_valid() to check
sf_newPar <- st_as_sf(SpatialPolygons(list(Polygons(list(Polygon(newPar)),1))))
# print("test2")
# Remove building parcel from new parcel
sf_bldg <- st_as_sf(SpatialPolygons(list(Polygons(list(Polygon(bldg)),1))))
sf_bldg <- st_buffer(sf_bldg, bldg_dist)
# print("test3")
# If there are intersections, this will split into multiple polygons. If not, nothing changes
split <- st_cast(st_make_valid(sf_newPar), "POLYGON")
split <- st_difference(split, sf_bldg)
# print(split)
if (length(split[[1]]) == 0){
return ("No suitable polygons")
}
# Get the order of polygons by largest to smallest
ord <- order(st_area(split), decreasing = TRUE)
# Initialize variable to keep track of all valid areas
polys <- NULL
for (i in 1:length(ord)){
inverted <- FALSE     # Track
poly <- split[ord[i],]
# If polygon is not inverted, return this polygon
# Check shortest distance between polygon centroid and each edge.
cent <- st_coordinates(st_centroid(poly))
for (j in 1:length(edges)){
if (edges[j] == "Front") {next} # Skip front facing, since we don't know the distance
else if (edges[j] == "Side") {dist <- side_dist}
else {dist <- rear_dist}
# distPtLineSeg <- function(x, y, x1, y1, x2, y2){
# If the distance > respective buffer, not inverted. Skip to next polygon
if (dist > distPtLineSeg(cent[1], cent[2], par[j,1], par[j,2], par[j+1,1], par[j+1,2])){
inverted <- TRUE
break
}
}
# If after checking all the sides, not marked as inverted, add this polygon
if (!inverted){
# polys <- rbind(polys, poly)
return(st_coordinates(poly)[,1:2])
}
}
#
# if (length(polys) > 0){
#
# }
# else{
return ("No suitable polygons")
# }
}
buffer <- function(par, ind, dist){
edge <- par[ind:(ind+1),]      # index and next point
# print(edge)
edge_mp <- colMeans(edge)      # Edge midpoint
# print(edge_mp)
edge_slope <- atan2(par[ind+1,2]-par[ind,2], par[ind+1,1]-par[ind,1])
# print(edge_slope)
offset <- dist * c(cos(edge_slope + pi/2), sin(edge_slope + pi/2))
# print(offset)
opt1 <- edge_mp + offset
# print(opt1)
opt2 <- edge_mp - offset
# print(opt2)
if (point.in.polygon(opt1[1],opt1[2],par[,1],par[,2]) == 1){ # If opt1 is inside polygon
vec <- c(cos(edge_slope), sin(edge_slope))
return (c(opt1, vec))
} else if (point.in.polygon(opt2[1],opt2[2],par[,1],par[,2]) == 1){ # If opt2 is inside polygon
vec <- c(cos(edge_slope), sin(edge_slope))
return (c(opt2, vec))
} else{
print("Buffer does not work for this polygon")
}
}
# Find which parcels are landlocked. These will need front edges manually identified
landlocked <- vector("logical", numPar - sum(checkFront))
index <- 1
for (i in 1:numPar){
if (!checkFront[i]){
landlocked[index] <- i
index <- index + 1
}
}
landlockedAPNs <- vector("logical", numPar - sum(checkFront))
for (i in 1:(numPar - sum(checkFront))){
print(i)
landlockedAPNs[i] <- parcel_data$APN[[landlocked[i]]]
}
landlocked[1]
parcel_data$APN[[1634]]
landlocked <- vector("logical", numPar - sum(checkFront))
index <- 1
for (i in 1:numPar){
if (!checkFront[i]){
landlocked[index] <- i
index <- index + 1
}
}
landlockedAPNs <- vector("logical", numPar - sum(checkFront))
for (i in 1:(numPar - sum(checkFront))){
print(i)
landlockedAPNs[i] <- parcel_data$properties.APN[[landlocked[i]]]
}
View(parcel_data)
landlocked <- vector("logical", numPar - sum(checkFront))
index <- 1
for (i in 1:numPar){
if (!checkFront[i]){
landlocked[index] <- i
index <- index + 1
}
}
landlockedAPNs <- vector("logical", numPar - sum(checkFront))
for (i in 1:(numPar - sum(checkFront))){
print(i)
landlockedAPNs[i] <- parcels$properties.APN[[landlocked[i]]]
}
write_csv(as.data.frame(landlockedAPNs), "landlockedAPNs.csv")
save.image(".RData")
