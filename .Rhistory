# table(numBlock)
## Function: Parcel vertices are reindexed to make sure that block points are not "wrapping around" and creating two "chunks" of block points.
## Chunk = consecutive block points
## False chunk = consecutive non-block points
# Example:
# Original parcel index  1 2 3 4 5
# Block point?           Y N N Y Y  (Two chunks, one false chunk)
# Reordered parcel index 4 5 1 2 3
# Block point?           Y Y Y N N  (One chunk, one false chunk)
# Each parcel is supposed to only have one "chunk" of block points. This reordering ensures that the data quality is good and is used to flag
# any parcels that have more than one chunk after reordering for manual review.
## Params:
##   i: index of parcel in parcel object.
## Returns:
##   modParcel: parcel object with modified indexing
##   flag: TRUE if more than one chunk and needs manual review. FALSE if no problems with modParcel
reIndex <- function(i){
chunks <- 0
false_chunks <- 0
preVal <- FALSE
arr <- parcelXY[[i]][-length(parcelXY[[i]]),]
for (j in 1:nrow(arr)){
if (j == 1 && arr[j,3] == 1){chunks <- chunks + 1}
else if (j == 1 && arr[j,3] == 0){false_chunks <- false_chunks + 1}
else if (preVal == FALSE && arr[j,3] == 1){chunks <- chunks + 1}
else if (preVal == TRUE && arr[j,3] == 0){false_chunks <- false_chunks + 1}
preVal <- arr[j,3]
}
offset <- 0
# First pass: if there are more true chunks, bring true chunk at end of index to the front
if (false_chunks < chunks){
for (j in nrow(arr):1){
if (arr[j,3] == 0){
break
}
offset <- offset + 1
}
# Reorder parcel by shifting indices back by offset (in beginning example, offset = 2)
arr <- rbind(arr[-1:-j,], arr[1:j,])
}
# Second pass: if there is a false chunk at the beginning, bring it to the back
chunks <- 0
false_chunks <- 0
preVal <- FALSE
for (j in 1:nrow(arr)){
if (j == 1 && arr[j,3] == 1){chunks <- chunks + 1}
else if (j == 1 && arr[j,3] == 0){false_chunks <- false_chunks + 1}
else if (preVal == FALSE && arr[j,3] == 1){chunks <- chunks + 1}
else if (preVal == TRUE && arr[j,3] == 0){false_chunks <- false_chunks + 1}
preVal <- arr[j,3]
}
offset <- 0
for (j in 1:nrow(arr)){
if (arr[j,3] == 1){
break
}
offset <- offset + 1
}
if (j != 1) {arr <- rbind(arr[-1:-offset,], arr[1:offset,])}
# If there are more than 1 chunk, unmark block points that are isolated
if (chunks > 1){
for (j in 1:nrow(arr)){
if (arr[j,3] == 1 && arr[(j - 2) %% nrow(arr) + 1,3] == 0 && arr[j + 1 %% nrow(arr),3] == 0){
arr[j,3] <- 0
}
}
}
# Third pass, flag any parcels with more than one chunk
chunks <- 0
false_chunks <- 0
preVal <- FALSE
for (j in 1:dim(arr)[1]){
if (j == 1 && arr[j,3] == 1){chunks <- chunks + 1}
else if (j == 1 && arr[j,3] == 0){false_chunks <- false_chunks + 1}
else if (preVal == FALSE && arr[j,3] == 1){chunks <- chunks + 1}
else if (preVal && arr[j,3] == 0){false_chunks <- false_chunks + 1}
preVal <- arr[j,3]
}
offset <- 0
for (j in 1:nrow(arr)){
if (arr[j,3] == 1){
break
}
offset <- offset + 1
}
if (j != 1) {arr <- rbind(arr[-1:-offset,], arr[1:offset,])}
arr <- rbind(arr, arr[1,])
arr[nrow(arr), 3] <- 0
flag <- chunks > 1
return(list(arr, flag))
}
# Run reIndex on all parcels
# Retain flags from chunks
flags <- as.data.frame(matrix(nrow = length(parcelXY), ncol = 1))
colnames(flags) <- "MultiChunk"
View(flags)
reIndex(1)[[1]]
reIndex(1)[[2]]
flags["MultiChunk",1]
flags["MultiChunk",1] <- reIndex(1)[[2]]
View(flags)
flags["MultiChunk",1] <- reIndex(1)[[2]]
View(flags)
str(flags)
reIndex(1)[[2]]
flags[1,1]
flags[1,1] <- TRUE
View(flags)
flags[1,1] <- reIndex(1)[[2]]
View(flags)
flags$MultiChunk[1] <- FALSE
flags$MultiChunk[1] <- TRUE
View(flags)
# Run reIndex on all parcels
# Retain flags from chunks
flags <- as.data.frame(matrix(nrow = length(parcelXY), ncol = 1))
colnames(flags) <- "MultiChunk"
for (i in 1:length(parcelXY)){
parcelXY[[i]] <- reIndex(i)[[1]]
flags$MultiChunk[i] <- reIndex(i)[[2]]
}
sum(flags$MultiChunk)
## Function: Extract block points as a separate array
## Params:
##   index: index of parcel
##   type: "Original" returns the original, "Mod" returns the block points after the front points were identified
## Returns:
##   n by 2 array of block point coordinates
parcelBlock <- function(index, type = "Original"){
if (type == "Original"){
if (numBlock[index] > 0){
return (parcelXY[[index]][(parcelXY[[index]][,3] == 1),1:2])
}
else{
print("This parcel has no block points. User needs to manually identify.")
return (NULL)
}
}
else if (type == "Mod"){
if (numBlock[index] > 0){
return (modParcel[[index]][(modParcel[[index]][,3] == 1),1:2])
}
else{
print("This parcel has no block points. User needs to manually identify.")
return (NULL)
}
}
else{
print("Type is wrong. Enter either Original or Mod")
return (NULL)
}
}
## Function: Plot parcel with front points bolded
## Params:
##   index: index of parcel
##   type: "Original" returns the original, "Mod" returns the block points after the front points were identified
## Returns:
##   plot
plotParcel <- function(index, type = "Original"){
if (type == "Original"){
eqscplot(parcelXY[[index]][,1:2], type='l')
points(parcelBlock(index), pch = 16)
}
else if (type == "Mod"){
eqscplot(modParcel[[index]][,1:2], type='l')
points(parcelBlock(index, "Mod"), pch = 16)
}
else{
print("Type is wrong. Enter either Original or Mod")
return (NULL)
}
}
parcelBlock(1)
plotParcel(1)
######## Rdata of all the raw data
##########################################
save.image("A2.RData")
View(flags)
#~#~# Quality Check
# Check if front edge vertices are properly marked
flags$Landlocked <- NA
#~#~# Quality Check
# Check if front edge vertices are properly marked
flags$Landlocked <- FALSE
for (i in 1:length(parcelXY)){
print(i)
if (is.null(parcelBlock(i))) {flags$Landlocked[i] <- TRUE}
if (sum(parcelXY[[i]][,3]) < 2) {misfits[i] <- TRUE}
#~#~# Quality Check
# Check if front edge vertices are properly marked
# else {
#   plotParcel(i)
# }   # Change it to plot the parcel and add the front points as dark circles
# Sys.sleep(0.05)  # Pause and continues automatically
# invisible(readline(prompt="Press [enter] to continue"))  # Manually press enter to continue
}
# Mark parcels that are "landlocked," aka do not have any vertices identified as block points.
flags$Landlocked <- FALSE
# Mark parcels that are "landlocked," aka do not have any vertices identified as block points.
flags$Landlocked <- FALSE
flags$OneBlockPt <- FALSE
for (i in 1:length(parcelXY)){
print(i)
if (is.null(parcelBlock(i))) {flags$Landlocked[i] <- TRUE}
if (sum(parcelXY[[i]][,3]) < 2) {flags$OneBlockPt[i] <- TRUE}
#~#~# Quality Check
# Check if front edge vertices are properly marked
# else {
#   plotParcel(i)
# }   # Change it to plot the parcel and add the front points as dark circles
# Sys.sleep(0.05)  # Pause and continues automatically
# invisible(readline(prompt="Press [enter] to continue"))  # Manually press enter to continue
}
sum(flags$MultiChunk)
sum(flags$Landlocked)
sum(flags$OneBlockPt)
# Run reIndex on all parcels
# Retain flags from chunks
flags <- as.data.frame(matrix(nrow = length(parcelXY), ncol = 2))
colnames(flags) <- c("APN","MultiChunk")
flags$APN <- list_apn
View(parcels)
# Run reIndex on all parcels
# Retain flags from chunks
flags <- as.data.frame(matrix(nrow = length(parcelXY), ncol = 2))
colnames(flags) <- c("APN","MultiChunk")
flags$APN <- parcels$APN
for (i in 1:length(parcelXY)){
parcelXY[[i]] <- reIndex(i)[[1]]
flags$MultiChunk[i] <- reIndex(i)[[2]]
}
parcelBlock <- function(index, type = "Original"){
if (type == "Original"){
if (numBlock[index] > 0){
return (parcelXY[[index]][(parcelXY[[index]][,3] == 1),1:2])
}
else{
print("This parcel has no block points. User needs to manually identify.")
return (NULL)
}
}
else if (type == "Mod"){
if (numBlock[index] > 0){
return (modParcel[[index]][(modParcel[[index]][,3] == 1),1:2])
}
else{
print("This parcel has no block points. User needs to manually identify.")
return (NULL)
}
}
else{
print("Type is wrong. Enter either Original or Mod")
return (NULL)
}
}
## Function: Plot parcel with front points bolded
## Params:
##   index: index of parcel
##   type: "Original" returns the original, "Mod" returns the block points after the front points were identified
## Returns:
##   plot
plotParcel <- function(index, type = "Original"){
if (type == "Original"){
eqscplot(parcelXY[[index]][,1:2], type='l')
points(parcelBlock(index), pch = 16)
}
else if (type == "Mod"){
eqscplot(modParcel[[index]][,1:2], type='l')
points(parcelBlock(index, "Mod"), pch = 16)
}
else{
print("Type is wrong. Enter either Original or Mod")
return (NULL)
}
}
######## Rdata of all the raw data
##########################################
save.image("A2.RData")
flags$Landlocked <- FALSE
flags$OneBlockPt <- FALSE
for (i in 1:length(parcelXY)){
print(i)
if (is.null(parcelBlock(i))) {flags$Landlocked[i] <- TRUE}
if (sum(parcelXY[[i]][,3]) < 2) {flags$OneBlockPt[i] <- TRUE}
#~#~# Quality Check
# Check if front edge vertices are properly marked
# else {
#   plotParcel(i)
# }   # Change it to plot the parcel and add the front points as dark circles
# Sys.sleep(0.05)  # Pause and continues automatically
# invisible(readline(prompt="Press [enter] to continue"))  # Manually press enter to continue
}
# Mark parcels that are "landlocked," aka do not have any vertices identified as block points.
flags$Landlocked <- FALSE
flags$OneBlockPt <- FALSE
for (i in 1:length(parcelXY)){
print(i)
if (is.null(parcelBlock(i))) {flags$Landlocked[i] <- TRUE}
if (sum(parcelXY[[i]][,3]) == 1) {flags$OneBlockPt[i] <- TRUE}
#~#~# Quality Check
# Check if front edge vertices are properly marked
# else {
#   plotParcel(i)
# }   # Change it to plot the parcel and add the front points as dark circles
# Sys.sleep(0.05)  # Pause and continues automatically
# invisible(readline(prompt="Press [enter] to continue"))  # Manually press enter to continue
}
plotParcel(533)
parcelXY[[533]]
parcelBlock(533)
plotParcel(1)
plotParcel(533)
plotParcel(3912)
parcelXY[[1634]]
parcelBlock(1)
## Function: Obtain slopes for edges connecting parcel's block point. The slopes will be used for corner parcels in combination
##   with the roadway network to properly identify the front edge, and the street edge
## Params:
##   i: index of parcel
## Returns:
##   corner parcel: double vector of angles in radians
##   not a corner parcel: NULL
cornerSlopes <- function(i){
if(sum(parcelXY[[i]][,3]) < 3){return(NULL)}
arr <- parcelBlock(i)
slope <- vector("double", nrow(arr) - 1)
for (j in 1:length(slope)){
slope[j] <- atan2(arr[j+1,2]-arr[j,2], arr[j+1,1]-arr[j,1])
}
return(slope)
}
## Function: finds normal distance between a point and a line segment
## Params:
##   x,y: coordinates for point
##   x1,y1: coordinates for first point representing line segment
##   x2,y2: coordinates for second point representing line segment
## Returns:
##   distance
## Source: https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points
perpDist <- function(x, y, x1, y1, x2, y2){
return (abs((y2-y1) * x - (x2-x1) * y + x2*y1 - y2*x1)/sqrt((y2 - y1)^2 + (x2 - x1)^2))
}
perpDist(10, 0, 0, 0, 5, 0)
## Function: finds shortest distance between a point and a line segment
## Params:
##   x,y: coordinates for point
##   x1,y1: coordinates for first point representing line segment
##   x2,y2: coordinates for second point representing line segment
##   type: specifies which distance is returned
## Returns:
##   for "Norm": normal distance. If point is outside of line segment, then shortest distance to the projected line segment
##   for "True": true distance. If point is outside of line segment, then the distance from point to the closer point of the line segment
## Source for Norm: https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points
shortestDist <- function(x, y, x1, y1, x2, y2, type = "Norm"){
if (type == "Norm"){
return (abs((y2-y1) * x - (x2-x1) * y + x2*y1 - y2*x1)/sqrt((y2 - y1)^2 + (x2 - x1)^2))
}
else if(type == "True"){
px <- x2 - x1
py <- y2 - y1
norm <- px * px + py * py
u <- ((x - x1) * px + (y - y1) * py) / norm
if (u > 1) {u <- 1}
else if (u < 0) {u <- 0}
xx <- x1 + u * px
yy <- y1 + u * py
dx <- xx - x
dy <- yy - y
return (sqrt(dx * dx + dy * dy))
}
else{
print("Type is wrong. Enter either Norm or True")
return (NULL)
}
}
perpDist(10, 0, 0, 0, 5, 0)
perpDist(10, 0, 0, 0, 5, 0, "True")
perpDist(10, 0, 0, 0, 5, 0, type = "True")
## Function: finds shortest distance between a point and a line segment
## Params:
##   x,y: coordinates for point
##   x1,y1: coordinates for first point representing line segment
##   x2,y2: coordinates for second point representing line segment
##   type: specifies which distance is returned
## Returns:
##   for "Norm": normal distance. If point is outside of line segment, then shortest distance to the projected line segment
##   for "True": true distance. If point is outside of line segment, then the distance from point to the closer point of the line segment
## Source for Norm: https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points
shortestDist <- function(x, y, x1, y1, x2, y2, type = "Norm"){
if (type == "Norm"){
return (abs((y2-y1) * x - (x2-x1) * y + x2*y1 - y2*x1)/sqrt((y2 - y1)^2 + (x2 - x1)^2))
}
else if(type == "True"){
px <- x2 - x1
py <- y2 - y1
norm <- px * px + py * py
u <- ((x - x1) * px + (y - y1) * py) / norm
if (u > 1) {u <- 1}
else if (u < 0) {u <- 0}
xx <- x1 + u * px
yy <- y1 + u * py
dx <- xx - x
dy <- yy - y
return (sqrt(dx * dx + dy * dy))
}
else{
print("Type is wrong. Enter either Norm or True")
return (NULL)
}
}
perpDist(10, 0, 0, 0, 5, 0, type = "True")
shortestDist(10, 0, 0, 0, 5, 0, type = "Norm")
shortestDist(10, 0, 0, 0, 5, 0, type = "True")
## Function: finds shortest distance between a point and a line segment
## Params:
##   x,y: coordinates for point
##   x1,y1: coordinates for first point representing line segment
##   x2,y2: coordinates for second point representing line segment
##   type: specifies which distance is returned
## Returns:
##   for "Norm": normal distance. If point is outside of line segment, then shortest distance to the projected line segment
##   for "True": true distance. If point is outside of line segment, then the distance from point to the closer point of the line segment
## Source for Norm: https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points
shortestDist <- function(x, y, x1, y1, x2, y2, type = "Norm"){
if (type == "Norm"){
return (abs((y2-y1) * x - (x2-x1) * y + x2*y1 - y2*x1)/sqrt((y2 - y1)^2 + (x2 - x1)^2))
}
else if(type == "True"){
px <- x2 - x1
py <- y2 - y1
norm <- px * px + py * py
u <- ((x - x1) * px + (y - y1) * py) / norm
if (u > 1) {u <- 1}
else if (u < 0) {u <- 0}
xx <- x1 + u * px
yy <- y1 + u * py
dx <- xx - x
dy <- yy - y
return (sqrt(dx * dx + dy * dy))
}
else{
print("Type is wrong. Enter either Norm or True")
return (NULL)
}
}
load("~/GitHub/maxrect/A2.RData")
# Mark parcels that are "landlocked," aka do not have any vertices identified as block points.
flags$Landlocked <- FALSE
flags$OneBlockPt <- FALSE
for (i in 1:length(parcelXY)){
print(i)
if (is.null(parcelBlock(i))) {flags$Landlocked[i] <- TRUE}
if (sum(parcelXY[[i]][,3]) == 1) {flags$OneBlockPt[i] <- TRUE}
#~#~# Quality Check
# Check if front edge vertices are properly marked
# else {
#   plotParcel(i)
# }   # Change it to plot the parcel and add the front points as dark circles
# Sys.sleep(0.05)  # Pause and continues automatically
# invisible(readline(prompt="Press [enter] to continue"))  # Manually press enter to continue
}
## Function: Obtain slopes for edges connecting parcel's block point. The slopes will be used for corner parcels in combination
##   with the roadway network to properly identify the front edge, and the street edge
## Params:
##   i: index of parcel
## Returns:
##   corner parcel: double vector of angles in radians
##   not a corner parcel: NULL
cornerSlopes <- function(i){
if(sum(parcelXY[[i]][,3]) < 3){return(NULL)}
arr <- parcelBlock(i)
slope <- vector("double", nrow(arr) - 1)
for (j in 1:length(slope)){
slope[j] <- atan2(arr[j+1,2]-arr[j,2], arr[j+1,1]-arr[j,1])
}
return(slope)
}
## Function: finds shortest distance between a point and a line segment
## Params:
##   x,y: coordinates for point
##   x1,y1: coordinates for first point representing line segment
##   x2,y2: coordinates for second point representing line segment
##   type: specifies which distance is returned
## Returns:
##   for "Norm": normal distance. If point is outside of line segment, then shortest distance to the projected line segment
##   for "True": true distance. If point is outside of line segment, then the distance from point to the closer point of the line segment
## Source for Norm: https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points
shortestDist <- function(x, y, x1, y1, x2, y2, type = "Norm"){
if (type == "Norm"){
return (abs((y2-y1) * x - (x2-x1) * y + x2*y1 - y2*x1)/sqrt((y2 - y1)^2 + (x2 - x1)^2))
}
else if(type == "True"){
px <- x2 - x1
py <- y2 - y1
norm <- px * px + py * py
u <- ((x - x1) * px + (y - y1) * py) / norm
if (u > 1) {u <- 1}
else if (u < 0) {u <- 0}
xx <- x1 + u * px
yy <- y1 + u * py
dx <- xx - x
dy <- yy - y
return (sqrt(dx * dx + dy * dy))
}
else{
print("Type is wrong. Enter either Norm or True")
return (NULL)
}
}
######## Rdata of all the raw data
##########################################
save.image("A2.RData")
