buffer <- function(st_par, ind, dist){
par <- st_coordinates(st_par)[,1:2]
edge <- par[ind:(ind+1),]      # index and next point
# Convert coordinates into st_linestring
line <- st_sfc(st_linestring(edge), crs = 102643)
# Buffer line seg by dist
buffered <- st_buffer(line, dist, nQuadSegs = 2, endCapStyle = "SQUARE") %>% st_make_valid()
return(buffered)
}
result <- allBuffers(st_par, edges, st_bldg, 5, 10, 12, 0)
result
View(result)
mapview(result)
plot(result)
length(result)
length(result[[1]])
st_geometry_type(result) == "GEOMETRYCOLLECTION"
View(result[[1]])
st_geometry_type(result[[1]][[1]])
st_geometry_type(result[[1]][[2]])
st_geometry_type(result[[1]][[1]]) == "LINESTRING"
st_geometry_type(result[[1]][[2]]) == "POLYGON"
# Check whether buffer overlaps with building. If it does, adjust so that there is no intersection in result
# Output: new parcel coordinates, array (n by 2)
## Function: Complete all buffers to remove side, street, rear, building setbacks.
## Params:
##   par: SF POLYGON buildable_area (after front yard cut)
##   edges: character vector label of what type of edges
##   bldg: SF POLYGON building footprint
##   side_dist/rear_dist/street_dist: distance in feet according to zoning codes
## Returns:
##   SF POLYGON object representing buildable area after all setbacks removed
allBuffers <- function(st_par, edges, st_bldg, side_dist, rear_dist, street_dist, bldg_dist = 0){
# Remove building footprint from parcel
result <- st_difference(st_buffer(st_par,0), st_buffer(st_bldg, bldg_dist, joinStyle = "MITRE", mitreLimit = 5))
#result <- st_difference(st_buffer(st_par,0), st_buffer(st_bldg, bldg_dist,nQuadSegs = 2, endCapStyle = "SQUARE", joinStyle = "MITRE", mitreLimit = 5) %>% st_set_precision(1e9)) #%>% st_buffer(-1e-9, joinStyle = "MITRE", mitreLimit = 5) %>% st_make_valid() %>% st_set_precision(1e9)
# result <- st_intersection(result, result)
for (i in 1:length(edges)){
if (edges[i,] == "Front"){next}
else if (edges[i,] == "Side"){
buff <- buffer(st_par, i, side_dist) #%>% st_set_precision(1e9)
# result <- st_intersection(result, result)
result <- st_difference(st_buffer(result, 0), buff)
#result <- st_difference(st_buffer(result, 0) %>% st_set_precision(1e9), buff) %>% st_buffer(-1e-9, joinStyle = "MITRE", mitreLimit = 5) %>% st_set_precision(1e9) %>% st_make_valid() %>% st_set_precision(1e9)
}
else if (edges[i,] == "Street"){
buff <- buffer(st_par, i, street_dist) #%>% st_set_precision(1e9)
# result <- st_intersection(result, result)
result <- st_difference(st_buffer(result, 0), buff)
#result <- st_difference(st_buffer(result, 0) %>% st_set_precision(1e9), buff) %>% st_buffer(-1e-9, joinStyle = "MITRE", mitreLimit = 5) %>% st_set_precision(1e9) %>% st_make_valid() %>% st_set_precision(1e9)
}
else if (edges[i,] == "Rear"){
buff <- buffer(st_par, i, rear_dist) #%>% st_set_precision(1e9)
# result <- st_intersection(result, result)
result <- st_difference(st_buffer(result, 0), buff)
#result <- st_difference(st_buffer(result, 0) %>% st_set_precision(1e9), buff) %>% st_buffer(-1e-9, joinStyle = "MITRE", mitreLimit = 5) %>% st_set_precision(1e9) %>% st_make_valid() %>% st_set_precision(1e9)
}
}
# Clean up. Get rid of any non-POLYGON SF object, and POLYGONs with areas less than 160
if (st_geometry_type(result) == "GEOMETRYCOLLECTION"){
newResult <- NULL
resultParts <- result[[1]]
for (j in 1:length(resultParts[[1]])){
part <- resultParts[[1]][[j]]
type <- st_geometry_type(part)
if (type == "POLYGON" || type == "MULTIPOLYGON"){
if (st_area(part) > 160){
newResult <- rbind(newResult, part)
}
}
}
result <- newResult
}
return (result)
}
result <- allBuffers(st_par, edges, st_bldg, 5, 10, 12, 0)
# Check whether buffer overlaps with building. If it does, adjust so that there is no intersection in result
# Output: new parcel coordinates, array (n by 2)
## Function: Complete all buffers to remove side, street, rear, building setbacks.
## Params:
##   par: SF POLYGON buildable_area (after front yard cut)
##   edges: character vector label of what type of edges
##   bldg: SF POLYGON building footprint
##   side_dist/rear_dist/street_dist: distance in feet according to zoning codes
## Returns:
##   SF POLYGON object representing buildable area after all setbacks removed
allBuffers <- function(st_par, edges, st_bldg, side_dist, rear_dist, street_dist, bldg_dist = 0){
# Remove building footprint from parcel
result <- st_difference(st_buffer(st_par,0), st_buffer(st_bldg, bldg_dist, joinStyle = "MITRE", mitreLimit = 5))
#result <- st_difference(st_buffer(st_par,0), st_buffer(st_bldg, bldg_dist,nQuadSegs = 2, endCapStyle = "SQUARE", joinStyle = "MITRE", mitreLimit = 5) %>% st_set_precision(1e9)) #%>% st_buffer(-1e-9, joinStyle = "MITRE", mitreLimit = 5) %>% st_make_valid() %>% st_set_precision(1e9)
# result <- st_intersection(result, result)
for (i in 1:length(edges)){
if (edges[i,] == "Front"){next}
else if (edges[i,] == "Side"){
buff <- buffer(st_par, i, side_dist) #%>% st_set_precision(1e9)
# result <- st_intersection(result, result)
result <- st_difference(st_buffer(result, 0), buff)
#result <- st_difference(st_buffer(result, 0) %>% st_set_precision(1e9), buff) %>% st_buffer(-1e-9, joinStyle = "MITRE", mitreLimit = 5) %>% st_set_precision(1e9) %>% st_make_valid() %>% st_set_precision(1e9)
}
else if (edges[i,] == "Street"){
buff <- buffer(st_par, i, street_dist) #%>% st_set_precision(1e9)
# result <- st_intersection(result, result)
result <- st_difference(st_buffer(result, 0), buff)
#result <- st_difference(st_buffer(result, 0) %>% st_set_precision(1e9), buff) %>% st_buffer(-1e-9, joinStyle = "MITRE", mitreLimit = 5) %>% st_set_precision(1e9) %>% st_make_valid() %>% st_set_precision(1e9)
}
else if (edges[i,] == "Rear"){
buff <- buffer(st_par, i, rear_dist) #%>% st_set_precision(1e9)
# result <- st_intersection(result, result)
result <- st_difference(st_buffer(result, 0), buff)
#result <- st_difference(st_buffer(result, 0) %>% st_set_precision(1e9), buff) %>% st_buffer(-1e-9, joinStyle = "MITRE", mitreLimit = 5) %>% st_set_precision(1e9) %>% st_make_valid() %>% st_set_precision(1e9)
}
}
# Clean up. Get rid of any non-POLYGON SF object, and POLYGONs with areas less than 160
# if (st_geometry_type(result) == "GEOMETRYCOLLECTION"){
#   newResult <- NULL
#   resultParts <- result[[1]]
#   for (j in 1:length(resultParts[[1]])){
#     part <- resultParts[[1]][[j]]
#     type <- st_geometry_type(part)
#     if (type == "POLYGON" || type == "MULTIPOLYGON"){
#       if (st_area(part) > 160){
#         newResult <- rbind(newResult, part)
#       }
#     }
#   }
#   result <- newResult
# }
return (result)
}
result <- allBuffers(st_par, edges, st_bldg, 5, 10, 12, 0)
st_geometry_type(result) == "GEOMETRYCOLLECTION"
newResult <- NULL
resultParts <- result[[1]]
for (j in 1:length(resultParts)){
part <- resultParts[[j]]
type <- st_geometry_type(part)
if (type == "POLYGON" || type == "MULTIPOLYGON"){
if (st_area(part) > 160){
newResult <- rbind(newResult, part)
}
}
}
result <- newResult
result
plot(result)
?st_sfc()
?st_polygon()
?st_combine()
result <- allBuffers(st_par, edges, st_bldg, 5, 10, 12, 0)
newResult <- st_sfc(st_polygon(list()), crs = 102643)
resultParts <- result[[1]]
for (j in 1:length(resultParts)){
part <- resultParts[[j]]
type <- st_geometry_type(part)
if (type == "POLYGON" || type == "MULTIPOLYGON"){
if (st_area(part) > 160){
newResult <- st_union(newResult, part)
}
}
}
result
resultParts
st_cast(result)
result <- allBuffers(st_par, edges, st_bldg, 5, 10, 12, 0)
if (st_geometry_type(result) == "GEOMETRYCOLLECTION"){
newResult <- st_sfc(st_polygon(list()), crs = 102643)
resultParts <- st_cast(result)
for (j in 1:length(resultParts)){
part <- resultParts[[j]]
type <- st_geometry_type(part)
if (type == "POLYGON" || type == "MULTIPOLYGON"){
if (st_area(part) > 160){
newResult <- st_union(newResult, part)
}
}
}
result <- newResult
}
newResult <- st_sfc(st_polygon(list()), crs = 102643)
resultParts <- st_cast(result)
resultParts
j <- 1
part <- resultParts[[j]]
part
part <- st_sfc(resultParts[[j]], crs = 102643)
part
type <- st_geometry_type(part)
type
if (type == "POLYGON" || type == "MULTIPOLYGON"){
if (st_area(part) > 160){
newResult <- st_union(newResult, part)
}
}
result <- newResult
result
result <- allBuffers(st_par, edges, st_bldg, 5, 10, 12, 0)
st_area(result)
result <- allBuffers(st_par, edges, st_bldg, 5, 10, 12, 0)
if (st_geometry_type(result) == "GEOMETRYCOLLECTION"){
newResult <- st_sfc(st_polygon(list()), crs = 102643)
resultParts <- st_cast(result)
for (j in 1:length(resultParts)){
j <- 1
part <- st_sfc(resultParts[[j]], crs = 102643)
type <- st_geometry_type(part)
if (type == "POLYGON" || type == "MULTIPOLYGON"){
if (st_area(part) > 160){
print("yes")
newResult <- st_union(newResult, part)
}
}
}
result <- newResult
}
newResult <- st_sfc(st_polygon(list()), crs = 102643)
resultParts <- st_cast(result)
result <- allBuffers(st_par, edges, st_bldg, 5, 10, 12, 0)
if (st_geometry_type(result) == "GEOMETRYCOLLECTION"){
newResult <- st_sfc(st_polygon(list()), crs = 102643)
resultParts <- st_cast(result)
for (j in 1:length(resultParts)){
part <- st_sfc(resultParts[[j]], crs = 102643)
type <- st_geometry_type(part)
if (type == "POLYGON" || type == "MULTIPOLYGON"){
if (st_area(part) > 160){
print("yes")
newResult <- st_union(newResult, part)
}
}
}
result <- newResult
}
st_area(result)
abs(st_area(result))
?set_units
units::set_units(160, US_survey_foot^2)
result <- allBuffers(st_par, edges, st_bldg, 5, 10, 12, 0)
if (st_geometry_type(result) == "GEOMETRYCOLLECTION"){
newResult <- st_sfc(st_polygon(list()), crs = 102643)
resultParts <- st_cast(result)
for (j in 1:length(resultParts)){
part <- st_sfc(resultParts[[j]], crs = 102643)
type <- st_geometry_type(part)
if (type == "POLYGON" || type == "MULTIPOLYGON"){
if (st_area(part) > units::set_units(160, US_survey_foot^2)){
print("yes")
newResult <- st_union(newResult, part)
}
}
}
result <- newResult
}
# Check whether buffer overlaps with building. If it does, adjust so that there is no intersection in result
# Output: new parcel coordinates, array (n by 2)
## Function: Complete all buffers to remove side, street, rear, building setbacks.
## Params:
##   par: SF POLYGON buildable_area (after front yard cut)
##   edges: character vector label of what type of edges
##   bldg: SF POLYGON building footprint
##   side_dist/rear_dist/street_dist: distance in feet according to zoning codes
## Returns:
##   SF POLYGON object representing buildable area after all setbacks removed
allBuffers <- function(st_par, edges, st_bldg, side_dist, rear_dist, street_dist, bldg_dist = 0){
# Remove building footprint from parcel
result <- st_difference(st_buffer(st_par,0), st_buffer(st_bldg, bldg_dist, joinStyle = "MITRE", mitreLimit = 5))
#result <- st_difference(st_buffer(st_par,0), st_buffer(st_bldg, bldg_dist,nQuadSegs = 2, endCapStyle = "SQUARE", joinStyle = "MITRE", mitreLimit = 5) %>% st_set_precision(1e9)) #%>% st_buffer(-1e-9, joinStyle = "MITRE", mitreLimit = 5) %>% st_make_valid() %>% st_set_precision(1e9)
# result <- st_intersection(result, result)
for (i in 1:length(edges)){
if (edges[i,] == "Front"){next}
else if (edges[i,] == "Side"){
buff <- buffer(st_par, i, side_dist) #%>% st_set_precision(1e9)
# result <- st_intersection(result, result)
result <- st_difference(st_buffer(result, 0), buff)
#result <- st_difference(st_buffer(result, 0) %>% st_set_precision(1e9), buff) %>% st_buffer(-1e-9, joinStyle = "MITRE", mitreLimit = 5) %>% st_set_precision(1e9) %>% st_make_valid() %>% st_set_precision(1e9)
}
else if (edges[i,] == "Street"){
buff <- buffer(st_par, i, street_dist) #%>% st_set_precision(1e9)
# result <- st_intersection(result, result)
result <- st_difference(st_buffer(result, 0), buff)
#result <- st_difference(st_buffer(result, 0) %>% st_set_precision(1e9), buff) %>% st_buffer(-1e-9, joinStyle = "MITRE", mitreLimit = 5) %>% st_set_precision(1e9) %>% st_make_valid() %>% st_set_precision(1e9)
}
else if (edges[i,] == "Rear"){
buff <- buffer(st_par, i, rear_dist) #%>% st_set_precision(1e9)
# result <- st_intersection(result, result)
result <- st_difference(st_buffer(result, 0), buff)
#result <- st_difference(st_buffer(result, 0) %>% st_set_precision(1e9), buff) %>% st_buffer(-1e-9, joinStyle = "MITRE", mitreLimit = 5) %>% st_set_precision(1e9) %>% st_make_valid() %>% st_set_precision(1e9)
}
}
# Clean up. Get rid of any non-POLYGON SF object, and POLYGONs with areas less than 160
if (st_geometry_type(result) == "GEOMETRYCOLLECTION"){
newResult <- st_sfc(st_polygon(list()), crs = 102643)
resultParts <- st_cast(result)
for (j in 1:length(resultParts)){
part <- st_sfc(resultParts[[j]], crs = 102643)
type <- st_geometry_type(part)
if (type == "POLYGON" || type == "MULTIPOLYGON"){
if (st_area(part) > units::set_units(160, US_survey_foot^2)){
newResult <- st_union(newResult, part)
}
}
}
result <- newResult
}
return (result)
}
load("~/GitHub/maxrect/D2.RData")
# Helper Function: buffer for one edge
# Input: parcel
# Param: edge_index, buffer distance
# Returns a buffer around the edge with distance dist
# Returns as a st_polygon
## Function: Create a buffer based on a polygon edge and dist. This will be used to remove setback areas from buildable_area
## Params:
##   st_par: SF POLYGON parcel object
##   ind: index of parcel
##   dist: buffer distance
## Returns:
##   SF POLYGON object representing buffer that needs to be subtracted
buffer <- function(st_par, ind, dist){
par <- st_coordinates(st_par)[,1:2]
edge <- par[ind:(ind+1),]      # index and next point
# Convert coordinates into st_linestring
line <- st_sfc(st_linestring(edge), crs = 102643)
# Buffer line seg by dist
buffered <- st_buffer(line, dist, nQuadSegs = 2, endCapStyle = "SQUARE") %>% st_make_valid()
return(buffered)
}
# Side, street, and rear buffers
# Input: parcel, edgeID (side, rear, street), building footprint, front points
# Param: side buffer dist, rear buffer dist
# Draw parallel lines that are [buffer dist] away from each side
# Select parallel lines that are closer to parcel centroid, so lines are going inward, not outward
# Find intersection between adjacent lines to reconstruct buffered parcel
# Check whether buffer overlaps with building. If it does, adjust so that there is no intersection in result
# Output: new parcel coordinates, array (n by 2)
## Function: Complete all buffers to remove side, street, rear, building setbacks.
## Params:
##   par: SF POLYGON buildable_area (after front yard cut)
##   edges: character vector label of what type of edges
##   bldg: SF POLYGON building footprint
##   side_dist/rear_dist/street_dist: distance in feet according to zoning codes
## Returns:
##   SF POLYGON object representing buildable area after all setbacks removed
allBuffers <- function(st_par, edges, st_bldg, side_dist, rear_dist, street_dist, bldg_dist = 0){
# Remove building footprint from parcel
result <- st_difference(st_buffer(st_par,0), st_buffer(st_bldg, bldg_dist, joinStyle = "MITRE", mitreLimit = 5))
#result <- st_difference(st_buffer(st_par,0), st_buffer(st_bldg, bldg_dist,nQuadSegs = 2, endCapStyle = "SQUARE", joinStyle = "MITRE", mitreLimit = 5) %>% st_set_precision(1e9)) #%>% st_buffer(-1e-9, joinStyle = "MITRE", mitreLimit = 5) %>% st_make_valid() %>% st_set_precision(1e9)
# result <- st_intersection(result, result)
for (i in 1:length(edges)){
if (edges[i,] == "Front"){next}
else if (edges[i,] == "Side"){
buff <- buffer(st_par, i, side_dist) #%>% st_set_precision(1e9)
# result <- st_intersection(result, result)
result <- st_difference(st_buffer(result, 0), buff)
#result <- st_difference(st_buffer(result, 0) %>% st_set_precision(1e9), buff) %>% st_buffer(-1e-9, joinStyle = "MITRE", mitreLimit = 5) %>% st_set_precision(1e9) %>% st_make_valid() %>% st_set_precision(1e9)
}
else if (edges[i,] == "Street"){
buff <- buffer(st_par, i, street_dist) #%>% st_set_precision(1e9)
# result <- st_intersection(result, result)
result <- st_difference(st_buffer(result, 0), buff)
#result <- st_difference(st_buffer(result, 0) %>% st_set_precision(1e9), buff) %>% st_buffer(-1e-9, joinStyle = "MITRE", mitreLimit = 5) %>% st_set_precision(1e9) %>% st_make_valid() %>% st_set_precision(1e9)
}
else if (edges[i,] == "Rear"){
buff <- buffer(st_par, i, rear_dist) #%>% st_set_precision(1e9)
# result <- st_intersection(result, result)
result <- st_difference(st_buffer(result, 0), buff)
#result <- st_difference(st_buffer(result, 0) %>% st_set_precision(1e9), buff) %>% st_buffer(-1e-9, joinStyle = "MITRE", mitreLimit = 5) %>% st_set_precision(1e9) %>% st_make_valid() %>% st_set_precision(1e9)
}
}
# Clean up. Get rid of any non-POLYGON SF object, and POLYGONs with areas less than 160
if (st_geometry_type(result) == "GEOMETRYCOLLECTION"){
newResult <- st_sfc(st_polygon(list()), crs = 102643)
resultParts <- st_cast(result)
for (j in 1:length(resultParts)){
part <- st_sfc(resultParts[[j]], crs = 102643)
type <- st_geometry_type(part)
if (type == "POLYGON" || type == "MULTIPOLYGON"){
if (st_area(part) > units::set_units(160, US_survey_foot^2)){
newResult <- st_union(newResult, part)
}
}
}
result <- newResult
}
return (result)
}
################################################################
save.image("D2.RData")
# 3339
for (i in 1:length(modParcel)){
if (sum(as.numeric(flags[i,-1])) == 0){
print(i)
st_par <- st_geometry(buildable_area[i,])
edges <- modParcel[[i]][,4]
st_bldg <- st_geometry(bldg_all[i,]) %>% st_buffer(0)
geom <- allBuffers(st_par, edges, st_bldg, 5, 10, 12, 0)
# if (is.character(geom) || nrow(geom) == 0){
#   sf <- st_sf(APN = parcels$properties.APN[[i]], valid = FALSE, geometry = st_sfc(st_polygon()))
# }
if (length(geom) == 0){
sf <- st_sf(APN = parcels$APN[i], geometry = st_sfc(st_polygon(), crs = 102643))
}
else{
sf <- st_sf(APN = parcels$APN[i], geometry = geom)
}
result_Bldg0 <- rbind(result_Bldg0, sf)
}
else{
sf <- st_sf(APN = parcels$APN[i], geometry = st_sfc(st_polygon(), crs = 102643))
result_Bldg0 <- rbind(result_Bldg0, sf)
}
}
# Find the available area after buffers. No building set back. Side = 5 ft, Rear = 10 ft, Street = 12 ft
buildable_area_a <- NULL
# Find the available area after buffers. No building set back. Side = 5 ft, Rear = 10 ft, Street = 12 ft
buildable_area_a <- NULL
# 3339
for (i in 1:length(modParcel)){
if (sum(as.numeric(flags[i,-1])) == 0){
print(i)
st_par <- st_geometry(buildable_area[i,])
edges <- modParcel[[i]][,4]
st_bldg <- st_geometry(bldg_all[i,]) %>% st_buffer(0)
geom <- allBuffers(st_par, edges, st_bldg, 5, 10, 12, 0)
# if (is.character(geom) || nrow(geom) == 0){
#   sf <- st_sf(APN = parcels$properties.APN[[i]], valid = FALSE, geometry = st_sfc(st_polygon()))
# }
if (length(geom) == 0){
sf <- st_sf(APN = parcels$APN[i], geometry = st_sfc(st_polygon(), crs = 102643))
}
else{
sf <- st_sf(APN = parcels$APN[i], geometry = geom)
}
buildable_area_a <- rbind(buildable_area_a, sf)
}
else{
sf <- st_sf(APN = parcels$APN[i], geometry = st_sfc(st_polygon(), crs = 102643))
buildable_area_a <- rbind(buildable_area_a, sf)
}
}
# 3339
for (i in 584:length(modParcel)){
if (sum(as.numeric(flags[i,-1])) == 0){
print(i)
st_par <- st_geometry(buildable_area[i,])
edges <- modParcel[[i]][,4]
st_bldg <- st_geometry(bldg_all[i,]) %>% st_buffer(0)
geom <- allBuffers(st_par, edges, st_bldg, 5, 10, 12, 0)
# if (is.character(geom) || nrow(geom) == 0){
#   sf <- st_sf(APN = parcels$properties.APN[[i]], valid = FALSE, geometry = st_sfc(st_polygon()))
# }
if (length(geom) == 0){
sf <- st_sf(APN = parcels$APN[i], geometry = st_sfc(st_polygon(), crs = 102643))
}
else{
sf <- st_sf(APN = parcels$APN[i], geometry = geom)
}
buildable_area_a <- rbind(buildable_area_a, sf)
}
else{
sf <- st_sf(APN = parcels$APN[i], geometry = st_sfc(st_polygon(), crs = 102643))
buildable_area_a <- rbind(buildable_area_a, sf)
}
}
# 3339
for (i in 1722:length(modParcel)){
if (sum(as.numeric(flags[i,-1])) == 0){
print(i)
st_par <- st_geometry(buildable_area[i,])
edges <- modParcel[[i]][,4]
st_bldg <- st_geometry(bldg_all[i,]) %>% st_buffer(0)
geom <- allBuffers(st_par, edges, st_bldg, 5, 10, 12, 0)
# if (is.character(geom) || nrow(geom) == 0){
#   sf <- st_sf(APN = parcels$properties.APN[[i]], valid = FALSE, geometry = st_sfc(st_polygon()))
# }
if (length(geom) == 0){
sf <- st_sf(APN = parcels$APN[i], geometry = st_sfc(st_polygon(), crs = 102643))
}
else{
sf <- st_sf(APN = parcels$APN[i], geometry = geom)
}
buildable_area_a <- rbind(buildable_area_a, sf)
}
else{
sf <- st_sf(APN = parcels$APN[i], geometry = st_sfc(st_polygon(), crs = 102643))
buildable_area_a <- rbind(buildable_area_a, sf)
}
}
# 3339
for (i in 3424:length(modParcel)){
if (sum(as.numeric(flags[i,-1])) == 0){
print(i)
st_par <- st_geometry(buildable_area[i,])
edges <- modParcel[[i]][,4]
st_bldg <- st_geometry(bldg_all[i,]) %>% st_buffer(0)
geom <- allBuffers(st_par, edges, st_bldg, 5, 10, 12, 0)
# if (is.character(geom) || nrow(geom) == 0){
#   sf <- st_sf(APN = parcels$properties.APN[[i]], valid = FALSE, geometry = st_sfc(st_polygon()))
# }
if (length(geom) == 0){
sf <- st_sf(APN = parcels$APN[i], geometry = st_sfc(st_polygon(), crs = 102643))
}
else{
sf <- st_sf(APN = parcels$APN[i], geometry = geom)
}
buildable_area_a <- rbind(buildable_area_a, sf)
}
else{
sf <- st_sf(APN = parcels$APN[i], geometry = st_sfc(st_polygon(), crs = 102643))
buildable_area_a <- rbind(buildable_area_a, sf)
}
}
